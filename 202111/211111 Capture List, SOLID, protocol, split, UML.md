# TIL (Today I Learned)

11월 11일 (목)

## 학습 내용
* 캡쳐리스트, 용도가 무엇일까?
* 계산기 프로젝트 STEP 2의 대한 고민
* 빈 프로토콜의 용도, 프로토콜의 장점
* SOLID 활동학습

&nbsp;

## 고민한 점 / 해결 방법
- # Capture List 
    캡쳐리스트는 주변 환경의 범위에서 참조한 변수들을 얼마나 강하게 캡쳐해야하는지를 명시하는 것으로 캡쳐리스트를 사용하여 메모리 누수를 일으키는 강한 참조 순환을 피할 수 있게 된다.
    캡쳐리스트에 명시한 요소가 참조타입이 아니라면 해당 요소들은 클로저가 생성될 때 초기화 된다.
    ## 용도
    * 클로저의 강한참조 순환 문제를 해결하기 위해 사용(참조타입)
    * 클로저 내부에서 클로저 외부의 값을 참조할 때 참조하는 값이 변경되면 클로저 내부에서도 참조하는 값 또한 바뀌게 되므로 이를 방지하고자 사용(값타입)
    ## 캡쳐하는 시점
    * 클로저가 생성되는 시점에 평가된다.
- split의 정확한 역할을 유추하지 못했다. 일단 오동나무의 조언에 따라 돌아가게끔 로직을 구성해보았다. 그랬더니 split의 파라미터를 사용하지 않는 로직이 되어버렸다. 리팩토링을 해보려고 했는데, Split의 파라미터를 어떻게 활용해야할지 모르겠다... 리뷰어인 엘림에게 조언을 구해보았으나, 캠퍼들과 함께 고민해보며 해결해나갈 수 밖에 없는 것 같다. 오동나무는 어떤 방향으로 코드를 짜라고 제시해줄수 없다고하고, 야곰은 UML을 이해한 방향으로 짜면 된다고 하니 남은 기한동안 다시한번 고민해보아야 겠다.
- 빈 프로토콜은 무언가를 묶어줄때...? 협업을 할때 유용한 것 같다.
    # 코다의 설명
    * Error 프로토콜을 예시로 하자면, 빈 프로토콜인 Error는 컴파일과 협업을 한다. 
    * 컴파일러: 니가 어떤일을 할지는 모르겠지만 Error라는 이름을 붙여주면 내가 Error라고 인식해볼게.
    * 즉 Error는 오직 **오류를 표현하기 위한 타입**이다.
    * 프로토콜은 규정을 주는 것과 유사하다.
    * 팀원과의 협업 예시
        * A라는 기능과 B라는 기능을 개발중.
        * A 기능이 먼저 개발되어야 한다.
        * 그러나 A의 주요 기능을 프로토콜로 정의해주면 B에서도 A의 기능을 가정하에[?] 병렬적으로 개발을 할 수 있다.
* 계산기 프로젝트로 정리하자면 CalculatorItem 프로토콜을 Double과 Operator가 왜 채택하도록 설정하는지를 고민해보면 이해가 될 것 같다.
* # SOLID란?
    * S (Single Responsibility Principle) : 단일 책임 원칙
        * 소프트웨어 요소(클래스, 함수 등)는 응집도 있는 하나의 책임을 갖는다. 새 기능을 추가할 때 변경하지말고 새 클래스나 함수를 만들어라
    * O (Open/Close Principle) : 개방/폐쇄 원칙
        * 소프트웨어 요소는 확장 가능하도록 열려있고 변경에는 닫혀있어야 한다. 새 기능을 추가할 때 변경하지 말고 새 클래스나 함수를 만들어라
    * L (Liscov Substitution Principle) : 리스코브 치환 원칙
        * 상속받은 타입은 기본타입으로 대체 가능해야한다. 자식클래스는 부모 클래스 동작을 바꾸지 않는다.
    * I (Interface Segregation Principle) : 인터페이스 분리 원칙
        * 상위 레벨 모듈은 하위레벨 모듈에 의존하면 안된다. 둘다 추상화 된 인터페이스에 의존해야 한다.
    * D (Dependency Inversion Principle) : 의존성 역전 원칙
        * 클라이언트 객체는 사용하지 않는 메소드에 의존하면 안된다.

    # 추구해야하는 가치

    ## 1순위 가독성, 커뮤니케이션
    * 개발자는 코드를 통한 커뮤니케이션
    * 읽고 이해할 수 없는 코드가 더욱 가치가 없다

    ## 2순위 단순성
    * 코드는 단순해야 한다.
    * 커뮤니케이션에 도움이 된다.
    * 버그가 생길 틈이 없어진다.
    * 미래의 확장을 위한 복잡한 패턴은 경계의 대상이다

    ## 3순위 유연성
    * 기존의 코드를 수정하는 데에 많은 시간을 소비한다.
    * 유연성과 단순성은 trade off
    * 그리고 “구현 패턴”을 쓴 저자 켄트의 말을 빌리자면 “가치는 원칙보다 높은 수준의 개념이다”, “원칙은 가치를 지키기위해서 존재해야 한다.”

    # 유연성은 그래서 언제 챙길까?
    처음엔 단순하게 > 기획 또는 정책의 변경이 발생 > 이 기획 또는 정책의 변경의 원인은 무엇일까? 그리고 이러한 변경은 계속 발생 가능한 일일까? > 리팩토링을 통해 확장성을 고려해서 변경해보자.
    > 3가지의 가치는 서로 하나의 목표만을 바라보는데 그것은 바로 시간이라고 한다. 프로그래밍 세계에서 비용이란? 즉 비용==시간 이다.

    개발에 있어서 가독성, 단순성, 유연성은 모두 개발, 리팩토링하는데 있어 시간을 줄여주기 때문에 매우 중요한 가치다.

    # SOLID 원칙을 왜 지켜야 할까?
    * 높은 코드 품질을 얻기 위해서
    * 높은 품질의 코드란 도대체 뭘까? 그리고 높은 품질의 코드는 왜 중요한가?에 대한 고민을 해보자.
    * 가치는 원칙보다 높은 수준의 개념
- # 붱이의 강의를 들으며 중요한 부분 메모
    - 엔지니어는 현재의 상황에서 우선순위를 계산하고 그에 맞는 최선의 선택만을 할 뿐 푀선의 선택을 위해서는 기준을 세워두어야 한다.
    - 객체 속성(데이터)을 가져오지 말고 객체가 일하도록 시켜라(연산실행) == 점 두개 쓰지 말라
    ## 테스트 주도 개발 관련
    - 제어흐름이 제대로 되는지에 대한 테스트를 해야한다.
    - 제어할 수 없는 부분을 Mock객체를 만들어서 제어할 수 있도록 구현하여 테스트를 한다.
    - 영향을 받는 객체들은 Mock을 활용하여 테스트를 한다.
    - 병렬적으로 개발을 한다.
        - 프로토콜 계층이 있으면 가능하다
    - SOLID 원칙으로 코드를 구현한다면 뷰를 나눠서 낄 수 있다. (예시: 콘솔용 뷰, 앱용 뷰)
    - 뷰는 언젠간 뚱뚱해질 수 밖에 없다.
    - 성능 측면 보다 코드의 복잡성을 관리하는 것이 어려운 순간이 더 많다.
    ## 공부법
    - 최신 트렌드가 중요하다.
    - 중요하다고 하는 것들은 일단 찾아본다. 그걸보고 놓치고 있었다는 사실을 인지한다. 얕게 처음 시작해보고 동시에 코드에서 다뤄보기도 해본다. 시험적인 것을 작게 시도해보고 재미가 없으면 필요한 순간에 다시 돌아온다.
    - 중요해보이는게 많은데 그거를 모든 걸 다해야하는 건 맞지만 뭐부터 할건지 선정하는 것도 중요하다. 그 시기에 해야할 것들은 다른 선배들에게 조언을 구해보는 것도 좋다.
    ## 테스트 가능한 코드를 작성하기 위한 원칙
    - 반환 값이 있는 것들을 인터페이스로 만드려고 한다.
    - 반환 값이 없는 것들은 외부 인터페이스로 빼두려고 한다.
    - 어떻게 하면 테스트 할 수 있을까? 부터 접근하기 시작한다.
    - 어떤 메서드가 public하게 있어야 테스트가 가능하겠구나~ 유추해본다.
    - 작은거부터 조립해나가는 경험을 할 수 있다.
    - Mock의 값이 제대로 전달되었는지도 테스트 해볼 수도 있다.
    - Mock은 꺼내서 볼 수 있는 존재다.
    - 테스트 거의 대부분 가짜 객체들이 필요하다.
    - 왜 필요하냐면 제어할 수 없는 부분이 있으니 제어할 수 있게 끔 Mock을 만들고 집어넣는다. 그럼 제어할 수 없는 부분을 제어할 수 있게 된다. 
        - -> 약간.. 돼지코 느낌이네...
    ## 코드를 짤때 우선순위를 정하는 꿀팁
    
    ![](https://i.imgur.com/ZVT4yFx.png)

    - 여러 군데에서 사용되는 부분.
        네트워크 같은 부분이 있다면 네트워크를 관리하는 오브젝트, 네트워크를 관리하는 오브젝트는 잘못되면 전반적인 피해를 끼친다.
    - 전반적으로 영향을 끼치는 부분
    - 잘 변하지 않는 부분 > 안정적인 테스트를 작성할 수 있는 환경
    - 데이터를 가져오는 Model 같은 부분은 잘 안변하고 View 같은 부분은 쉽게 변한다.
    - `모델로 보는 부분` 네트워크, 데이터모델, 유저모델, 가위바위보게임 등 
    - 만약 테스트를 한다면 모델레이어 부터 테스트를 시작한다. 그다음은 컨트롤러, 그다음은 뷰 순서
    - 결국 중요한 영역은 잘변하지 않는 영역이 된다.
    - `제어가 어려운 영역` UIKit, IBOutlet, IBAction 등
    - 이런 부분은 보통 과감하게 테스트를 포기한다. 화면 전환 테스트를 예를 들자면 `버튼이 눌렀을 때 전환되야해`, `백그라운드 컬러를 설정했을 때 배경색이 잘 변경되야해` 등 이런 부분은 우리가 테스트할 영역이 아니다.
    - 만약에 이런 영역들을 테스트 해야한다면 버튼이 눌렸을 때 이 이벤트를 관리할 수 있는 곳으로 넘겨준다. `버튼이 눌리면 이벤트를 전달해줘!!!` 식의 느낌....?
    - VC에서 버튼이 눌린다면 View Model에 넘겨준다. 즉 프레젠트를 바로 호출하는게 아니라 데이터를 넘겨준 뒤 호출하는 느낌?
    - 이런식으로 제어할 수 있는 영역을 늘려간다. 

    ## 무엇을 위주로 공부하면 좋은가?
    - 신입 입사에 맞는 것을 하면 좋다.
    - 실수를 많이하는 부분을 제일 많이 물어본다. 클래스와 구조체, ARC, 메모리 관리, 쓰레드, GCD, 이벤트가 전달되는 과정 등 이런 부분을 딥하게 알고 있는 것이 좋다.
    - UIKit을 예를 들자면 ViewController의 Life Cycle을 디테일하게 알고있는가?
        - 예시) ViewWillAppear에서 해서는 안되는 동작들이 ViewDidAppear에서 하는 것들이 있다.
    - 깊은 이해가 중요하고 사고력도 중요하다.
    - 최적화에 관한 질문도 나온다.
    - 실제 사례에서 실험을 해보았는지?
    - 이게 어떻게 되는거지? 라는 정신으로 실험해보는 것도 중요함.
    - 자료구조 명확히 설명하는 거 중요.
    - 연습을, 훈련을 극단적으로 해보는 습관을 길러보자.
    - SOLID는 다 적용해보는 것 보다 하나씩 적용해보는 걸 해보자.

&nbsp;

---

- 참고링크
    - [Capture List](https://velog.io/@kimdo2297/%ED%81%B4%EB%A1%9C%EC%A0%B8-%EC%BA%A1%EC%B3%90%EC%97%90-%EB%8C%80%ED%95%B4%EC%84%9C-about-closure-capture)
    - 붱이의 SOLID 혜자 강의
    
