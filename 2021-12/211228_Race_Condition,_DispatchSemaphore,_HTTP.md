# 211228 Race Condition, DispatchSemaphore, HTTP
# TIL (Today I Learned)


12월 28일 (화)

## 학습 내용
- 은행창구매니저 STEP3 PR 작성
- 은행창구매니저 STEP4 설계
- Race Condition 발생을 방지하기 위한 다양한 방법
- HTTP가 뭐지?

&nbsp;

## 고민한 점 / 해결 방법

**[Race Condition 발생 방지하기]**

* `애플사이다`, `july`, `namu`가 프로젝트 코드를 보고 야곰닷넷 카드뽑기와 유사하면서도 간단한 방법으로 은행을 돌리고 있는데, 해당 코드가 왜 Race Condition이 발생하지 않는 것인지 질문해주었다.
    * 나도 이 부분에 대해서 깊이 고민해보지 않았기 때문에(잘 돌아가서...) 제대로 설명할 수 없었고, 또 다시 삽질의 현장으로.....

```
📄 테스트 환경

- 아리, 허황의 스텝3 코드
- banking 의 speed 0초
- setUpBankCustomers의 range 100...100
- loanBankersCount 10명, depositBankersCount 20명
```

- 은행원의 수만큼 DispatchQueue를 만들어주고 있고, 그 안에서 dequeue를 하기 위해 고객의 큐에 접근하고 있다.
    - 여러 스레드에서 고객의 큐를 접근할 수 있는 가능성이 있다.
    - 그러나 현재 우리 코드에서는 race condition없이 잘 작동한다. 이유가 무엇일까?
        1. 일단 은행원의 수(DispatchQueue)가 적다. 3개뿐이다. 따라서 스레드는 3개 이상 생기지 않는다.
        2. 그리고 각 업무를 할때 스레드를 잠재운다. 딜레이가 있다.
        3. 고객의 숫자도 적은편이다.
    - 따라서 결론은 현재 셋팅(`은행원 수`, `고객 수`, `딜레이`) 때문에 race condition이 발생하지 않는다는 판단이 들었다.
    - 현재는 race condtion이 발생하지 않고 정상적으로 작동하지만, 결국에 `Queue`는 `Thread-Safe` 하지 않기 때문에, race condition이 발생하지 않을 것이라고도 장담할 수 없다는 결론이다.
        - 따라서 DispatchSemaphore를 사용해서 접근할 수 있는 스레드의 수를 제한해주는 것이 안전할 것 같다.
            - 하지만 이 방법도 테스트 결과 `customers.dequeue` 작업들이 for문으로 인해 작업이 쌓여있고, 큐의 접근을 세마포어로 제한하고 있으니, 제한하는 동안 쌓인 작업들이 제한이 풀리고 실행되면 비어있는 큐에 접근할 수 있기 때문에 fatalError가 발생할 수 있다.
        - 현재 global()로 동시성큐를 사용하고 있는데, 이 부분을 Serial Queue로 만들어서 질서를 지키게 해주면 매우 안전할 것 같다. 👍
            - 테스트 해보았는데 race condition 발생 안한다!!!!!
* **개선된 코드**
- ![](https://i.imgur.com/R2jT5ox.png)
    * 멤버변수로 Serial Queue를 생성해주고 DispatchQueue.global() 대신 직접 생성해준 bankerQueue를 사용하도록 개선하였다.
        * DispatchQueue가 지역변수가 아니라 멤버변수여야하는 이유는 뭘까?
            * DispatchQueue에 비동기로 큐를 보내고 있는 부분이 for문에 의해 4번 불린다고 했을 때, 지역변수로 DispatchQueue가 4개, 즉 각각의 작업마다 생성될테니 실질적으로 동시에 접근하는 것을 막아주지 못할 것이다.
            * 따라서 for문 내부에서 Queue를 생성하는 것이 아니라 바깥에서 생성해서, 그 해당 큐를 사용하는 방식으로 활용해야 한다.
            * Semaphore를 활용할 때에도 위와 마찬가지로 멤버변수여야 한다!!!!

---

**[Server와 통신하는 방법]**

* Socket 통신
    * 한번 연결에 성공하면 연결이 계속 유지된다.
    * 임의로 끊거나 네트워크 사정 상 끊기는 것이 아니라면 말이다.
    * 따라서 연속적(실시간)으로 데이터를 받아야하는 경우인 실시간 스트리밍, 채팅 같은 서비스에 사용된다.
    * 양방향 통신이다.
        * Client가 Server에게 데이터를 요청하지만
        * 반대로 Server가 Client에게 데이터를 요청할 수도 있다.
* HTTP 통신
    * Client에서 데이터가 필요할 때마다 Server에게 요청하고 Server는 그 데이터를 응답한다. 그리고 바로 연결이 종료되는 방식이다.
    * 우리가 주로 사용하는 블로그, 사이트 페이지 또한 처음 로드될 때 HTTP 통신으로 Server로 부터 데이터를 받아와 보여주는 것이고 바로 연결이 끊겼을 것이다.
        * 이후 다른 페이지를 가거나, 화면을 새로고침 하면 또 HTTP 통신으로 Server로부터 데이터를 받아와 보여주고 바로 연결이 끊긴다.
    * 이처럼 HTTP 통신은 단방향 통신이다.
        * Clinet만 Server에게 요청할 수 있고
        * Server는 Clinet에게 요청할 수 없다.
    * 보통 실시간으로 서비스해야하는 경우를 제외하곤 이 HTTP 통신을 사용한다.
        * Server의 부하를 줄여준다는 장점이 있다.
    * 계속 연결을 맺는게 아닌, 원하는 요청에 대한 데이터만 던져주고 끊기므로 Server가 다른 접속들도 원활히 처리할 수 있어진다.

**[HTTP 메세지]**
* Client가 Server에게 무엇인가를 요청할 때 일정한 형식을 갖춰서 텍스트 기반의 메세지로 변환해서 전달해야한다.
    * 이 때 이 메세지의 형식을 바로 HTTP 메세지라고 한다.
* 보통 이 HTTP 메세지를 만들고 변환하는 과정은 대부분 브라우저의 몫인데, iOS 앱의 경우는 HTTP 메세지를 직접 만들어 전송해주어야 한다.
    * 물론 잘짜여진 라이브러리를 사용해도 되지만, 개념은 알고가야 한다.
* 메세지 구조?
    * 요청 메시지와 응답 메세지로 나뉜다.
    * 이 두 메세지는 라인, 헤더, 바디 세 부분으로 구성된다.
    * ![](https://i.imgur.com/0nAswjY.png)
    * 라인
        * 기본내용인 응답/요청 여부, 메세지 전송 방식, 상태 등이 작성된다.
        * 매우 정형화되어 있어 무조건 한 줄로만 작성된다.
            * POST /userAccount\login HTTP/1.1
                * 가장 처음에 POST/GET 등의 전송 메소드를 정의하며 시작한다.
                * 뒤이어 요청내용에 대한 경로가 오고,
                * 마지막으로 요청 형식에 대한 버전 정보가 온다.
    * 헤더
        * 메세지 본문에 대한 메타 정보가 들어가는 부분
        * 필요한 만큼 여러줄로 작성된다.
        * 길이가 유동적이므로 바디와 구분을 짓기 위해 한줄의 공백을 삽입한다.
            * HTTP 메세지에서 나타나는 첫 번째 한줄의 공백이 헤더와 바디를 구분하는 경계선이다.
                ```
                Host: swiftapi.rubypaper.co.kr:2029.
                Content-Type: application/json
                ```
                * Host란 Key에는 도메인 및 포트번호가 Value로 온다.
                * Content-Type에는 Key에는 메세지 바디의 타입을 나타내는데, 우리가 사용하는 JSON은 application/json 이라고 설정해주면 된다.
    * 바디
        * 실제로 보내고자 하는 메세지 본문 내용이 들어가는 부분으로 길이가 유동적이다.
        * 바디에 들어가는 메세지 형식은 헤더의 Content-Type에서 설정한 Type과 일치해야 한다.
        * JSON으로 설정한 경우에는 { "name" : "Ari" } 이런식으로 들어가야한다.
    * 라인 처음에 정의하는 전송 메소드에는 크게 2가지 전송방식이 있다.
        * 이에 따라 HTTP 메세지의 형태가 바뀐다.
    * POST
        ```
        POST /userAccount/login HTTP/1.1   // (1) 라인
        Host: swiftapi.rubypaper.co.kr:2029.  // (2) 헤더
        Content-Type: application/x-www-form-urlencoded   // (2) 헤더

        account=swift%40swift.com&passwd=1234&grant_type=password  // (3) 바디 
        ```
        * 앞서 위에서 공부한 내용이 POST 방식이다.
            * 헤더에 Content-Type을 명시하고 바디에 Content Type에 맞는 데이터를 넣는 것
        * HTTP 메세지가 달라지는 것은 POST가 아니라 바로 GET이다.
    * GET
        ```
        GET /userAccount/login?account=swift@swift.com&amp;passwd=1234&amp;grant_type=password HTTP/1.1  // (1) 라인

        Host: swiftapi.rubypaper.co.kr:2029   // (2) 헤더
        Content-Type: no-cache   // (3) 헤더
        ```
        * 라인이 엄청 길어지고 바디가 사라진다.
        * 자세히 보면 바디가 사라졌지만 바디에 있던 내용이 라인의 경로 뒤에 물음표(?)와 함께 합쳐져 버렸다.
        * 또한 헤더의 Content-Type도 no-cache로 바뀌었다.
        * 이처럼 GET에서는 메세지 본문을 사용하지 않고 본문의 파라미터를 모두 URL 뒤에 연결해서 전달해버린다.
            * 이렇게 연결되는 파라미터를 쿼리 스트링(Query String)이라고 한다.
        * 본문을 사용하지 않기 때문에 헤더의 Content-Type이 사용되지 않는다.
        * URL 뒤에 쿼리 스트링만 연결하면 되기 때문에 간결하게 정보를 전달할 수 있는 장점이 있다.
            * 하지만 URL 경로의 허용범위가 1024Byte이기 때문에 긴 값은 전송할 수 없다.
        * 따라서 데이터를 전송할 때 보다 필요한 정보를 요청할 때 주로 사용된다.
    * POST를 언제 사용해야할까?
        * 서버에게 동일한 요청을 여러번 전송해도 응답은 항상 다를 수 있을 때 사용한다.
        * 서버의 상태나 데이터를 변경 시킬 때
            * 예시로 게시글을 쓰고 삭제하는 것은 데이터가 변경되는 것이므로 POST로 요청해야한다.
        * POST, PUT, DELETE가 있기도 하다.
    * GET은 언제 사용하지?
        * 서버에게 동일한 요청을 여러번 전송하더라도 동일한 응답이 돌아와야할 때 사용한다.
        * 서버의 상태나 데이터를 변경시키지 않을 때 사용하는데,
            * 조회할 때 주로 사용한다.
                * 게시글을 조회한다던지…
        * 서버 데이터가 변경되지 않는 것은 GET으로!

**[RESTful API]**
* REST는 어떠한 네트워크 프로토콜도 아니다.
* HTTP에서 데이터를 주고 받을 때, 간단히 주고 받자해서 정의된 간단한 형식의 인터페이스를 뜻한다.
* 이러한 REST 구조를 따라 구현된 시스템을 바로 RESTful 이라고 부른다.
* 매우 쉽고 간단하게 구현할 수 있어서 대부분 모바일 통신은 RESTful 기반이다.
* RESTful 기반으로 서버에서 요청과 응답을 주고 받을 수 있도록 정의된 형식을 바로 RESTful API라고 부른다.
    * REST 형식이 궁금하다면?
        * https://meetup.toast.com/posts/92
* 이 RESTful API에서 주고받는 내용들은 모두 HTTP 메세지의 본문에 담겨서 전달되는데, RESTful API는 메세지 본문을 JSON 형태로 구성해서 보낸다.
    * 따라서 RESTful API로 통신하기 위해선 JSON 데이터 형식을 잘 알아야 한다.

**[HTTPS]**
* HTTP는 다음과 같이 암호화 되지 않은 평문으로 데이터를 전송한다.
* ![](https://i.imgur.com/uigDXFS.png)
* 따라서 누군가 패킷을 훔쳐보는 스니핑(Sniffing) 공격에 취약하다.
* HTTP 통신에선 Wire Shark를 통해 패킷을 확인하면 내 주민번호가 그대로 서버로 전송되는 것을 볼 수 있다.
    * 누가 패킷을 훔쳐보면 내 주민번호는 그대로 털리는 것…
* 때문에 서버와 클라이언트 간 데이터를 보호하기 위해선 패킷을 암호화 한 뒤 전송해야 한다.
* ![](https://i.imgur.com/owNyiHk.png)
* 이것이 바로 HTTPS다.
* 이때 사용하는 보안인증(암호화 + 서버인증 등)이 TLS(SSL)이다.
* 요약하자면 HTTP 통신에서 보안을 추가한 것이 HTTPS 라는 것
* 참고로 애플은 2016년 10월 경부터 앱스토어에 등록되는 모든 앱은 HTTPS 프로토콜을 이용한 네트워크 통신만 허용하고 있다.
* 따라서 서버와 연동하는 앱이라면 서버에서 미리 인증서를 발급받아 준비해두어야 한다.
---

- 참고링크
    - 오동나무 최고...👍
    - https://babbab2.tistory.com/70
