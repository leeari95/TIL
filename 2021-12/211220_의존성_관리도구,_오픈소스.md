# 211220 의존성 관리도구, 오픈소스
# TIL (Today I Learned)


12월 20일 (월)

## 학습 내용
- 의존성 관리도구 활동학습
- 은행 창구 매니저 STEP 1 진행

&nbsp;

## 고민한 점 / 해결 방법
**[카훗 오답노트]**

* 접근성이란?
    * 사용자의 신체적 특성이나, 지역, 나이, 지식 수준, 기술 체험과 같은 제한 사항을 고려하여 가능한 많은 사용자가 불편 없이 이용할 수 있도록 제품, 서비스를 만들어 제공하는 개념
* VoiceOver를 통해 읽어주는 Accessibility의 property
    * label
    * title
    * value
    * type
* Race Condition
    * 두 개 이상의 프로세스나 스레드가 하나의 데이터를 공유할 때 데이터가 동기화되지 않는 상황을 뜻한다.

---

**[라이브러리와 프레임워크 구분을 쉽게 하는 방법]**

* 이게 없어도 앱을 만들 수 있는지를 생각하면 된다.
    * 만들 수 있으면 라이브러리
    * 만들 수 없으면 프레임워크
* 그 위에서 코드를 작성한다면 프레임워크, 코드를 가져다 쓴다면 라이브러리

---

**[Dynamic과 Static]**

* 빌드할 때 Dynamic으로 혹은 Static으로 프레임워크를 생성할지 설정해줄 수 있다. 이 두개의 차이는 무엇일까?
    * 두개의 차이는 `컴파일된 코드를 참조하는 방식`에 있다
* Dynamic 라이브러리
    * 런타임 상에서 Mach-O 파일과 연결 (`참조`관계)
    * 필요에 의해 동적으로 메모리에 로드 된다.
    * 라이브러리에 대한 참조만 포함
* Static 라이브러리
    * 앱이 사용하는 프레임워크의 코드는 컴파일 시간동안 'Static Linker'에 의해 앱의 실행파일 안에 `복사`
    * 정적으로 메모리에 로드 된다.
    * 라이브러리 코드가 모두 포함
---

**[의존성 관리도구와 Git을 함께 사용할 때 주의할 점]**

* 이전 버전의 프로젝트에서 외부 라이브러리의 '최신화'를 유지한 경우 (pod file에서 버전을 명시해주지 않으면 자동으로 최신버전 유지가 된다.)
    * 이전 버전의 프로젝트를 사용하려는 경우에 코드는 이전 라이브러리에 맞춰져있지만 라이브러리는 최신 버전이어서 하위 호환이 안될 수 있다.
* 프로젝트 main 브랜치에서 라이브러리를 고정시켜놓은 경우
    * develop 브랜치에서 라이브러리를 업데이트 시키는 경우 나중에 배포를 위해 main 브랜치로 병합할 때, 라이브러리의 버전이 달라 충돌이 일어날 수 있다.
* 두개의 라이브러리를 채택한다고 할 때 각 라이브러리가 같은 하위 라이브러리를 채택하지만 두 라이브러리가 버전이 다른 경우 충돌이 날 수 있다.
* ### 따라서 정리하자면...
    * 외부 라이브러리의 코드를 commit에 남길 필요가 없으므로 podfile은 gitignore파일에 넣어주는 것이 좋다.
    * 만약 gitignore에 넣지 않으면 라이브러리 코드가 업데이트될 때마다 새로운 diff(difference)가 생긴다.
    * 코드가 github에 열려있는 한 외부 라이브러리의 코드는 언제든 가져올 수 있기 때문에 굳이 프로젝트 파일에 넣어주지 않아도 된다.

---

**[라이브러리를 가져올 때 특정 버전을 명시해주었을 때?]**

* 장점
    * 명시를 하지 않을 때와 달리 어떤 버전을 가지고 사용해야하는지 버전이 명확해지는 장점이 있다.
* 단점
    * 반대로 라이브러리가 업데이트 되면 특정한 기능을 사용할 수 없는 경우가 발생할 수도 있고, 혹은 업데이트 된 기능을 바로 사용할 수 없고 한번 재정비 후에 사용해야하는 경우도 발생할 수 있을 것 같다.

---

**[야곰닷넷 오픈소스 라이브러리 만들기]**

* 오픈소스란?
    * 소스코드를 공개해 특별한 제한 없이 그 코드를 볼 수 있도록 한 소스코드
        * 네트워킹 라이브러리인 Alamofire
        * 이미지를 관리해주는 Kingfisher
    * 라이선스 종류에 따라 다르지만 자유롭게 사용할 수 있어 라이브러리 개선에도 참여할 수 있다.
    * IT 생태계의 근간을 이뤄나가는 원동력에 오픈 소스가 큰 기여를 하고 있다.
* 오픈소스 제작의 의미
    * 자신의 코드를 공개하는 것은 부끄러울 수도 있지만 그만큼 더 신경쓰고 더 고민해서 코드를 짜게 하는 원동력이 될 수도 있다.
    * 왜 그렇게 짜여져 있었는지 어떻게 내가 원하는 버전을 사용할 수 있었는지 깨닫는데 도움이 될 것이다.
    * 경력 쌓기 힘든 주니어 개발자에게는 색다른 경력을 쌓는 길이 될 수도 있다.
        * 성장한 과정을 직접적으로 보여줄 수 있기 때문에 중고신입으로 가기 위한 지름길이 아닐까?
    * 지나가던 고수님께서 내가 모르던 부분을 집어주실 수 있고 코드를 수정해주실 수도 있다.
* 의존성 관리도구
    * 애플리케이션 기능을 개발하기 위해 외부 라이브러리를 사용할 때 프로젝트와 해당 라이브러리의 상관관계를 용이하게 관리해주는 도구
    * 내부 모듈을 분리하여 관리할 때도 사용 가능
        * Java는 Maven
        * Javascript는 Yarn, NPM
        * Python은 Pyenv
    * 코코아, 코코아터치 애플리케이션 개발환경에는?
        * 코코아팟(Cocoapods)
            * 장점
                * 사용하기 쉽다
                * Dynamic, Static 라이브러리를 모두 지원한다. (1.5.0 버전 이상)
                * 의존성의 의존성까지 자동으로 관리해준다.
                * 누구나 쉽게 어떤 의존성이 애플리케이션에 있는지 알 수 있다.
                * Pod outdated 명령어로 쉽게 새로운 버전이 있는지 체크할 수 있다.
                * 거의 대부분의 라이브러리가 코코아팟을 지원한다.
            * 단점
                * 라이브러리를 다운받아 설치하는데 오랜 시간이 걸린다.
                * 프로젝트를 빌드 할 때마다 모든 팟 라이브러리가 같이 빌드되므로 다른 도구를 사용할 때 보다 프로젝트 빌드 시간이 느리다.
        * 카르타고(Carthage)
            * 장점
                * Dynamic, Static 라이브러리를 모두 지원한다. (0.30.0 버전 이상)
                * 의존성의 의존성까지 자동으로 관리해준다.
                * 누구나 쉽게 어떤 의존성이 애플리케이션에 있는지 알 수 있다.
                * carthage outdated 명령어로 쉽게 새로운 버전이 있는지 체크할 수 있다.
                * carthage update를 실행할때만 한 번 프레임워크를 빌드하므로 코코아팟에 비해 프로젝트 빌드 속도가 빠르다.
                * 처음에 프레임워크를 추가하는 것 외에 프로젝트 설정이 바뀌지 않는다.
            * 단점
                * 의존성이 추가될 때마다 해줘야하는 번거로운 작업이 있다.
                * 사용자나 인기가 많은 라이브러리가 아니라면 카르타고를 지원하지 않을 수도 있다.
        * 스위프트 패키지 매니저(Swift Package Manager)
            * 장점
                * 애플이 지원한다.
                * Dynamic, Static 라이브러리를 모두 지원한다. (4.0 버전 이상)
                * 의존성의 의존성까지 자동으로 관리해준다.
                * 누구나 쉽게 어떤 의존성이 애플리케이션에 있는지 알 수 있다.
                * 스위프트 언어에 built-in 되어있어 별다른 설치가 필요없다. (Swift 3 이상)
                * 스위프트 언어에 built-in 되었기 때문에 Xcode Project 파일이 꼭 필요한 것이 아니므로 리눅스에서도 사용할 수 있다.
                * Pacage.swift 파일 이외에 수행할 설정이 없다.
                * Xcode의 GUI 환경에서 관리가 가능하다 (11.0 버전 이상)
            * 단점
                * 아직은 지원하지 않는 라이브러리가 많다.
                * 현 시점 해결되지 않은 이슈가 270건이 있다.
    * 의존성 관리도구를 사용하는 것이 필수는 아니다.
    * 하지만 사용하지 않을 경우 그 만큼 불필요한 공수가 발생할 수 있다.
        * 예를 들어 외부 라이브러리를 직접 프로젝트에 적절히 포팅하여 삽입하는 작업 같은 것
        * 해당 라이브러리에 대한 업데이트가 생겨 버전이 올라간다면 라이브러리를 교체해줘야 하는 경우
        * 일일히 기존 라이브러리를 삭제하고 새로 삽입시켜야 하는 경우
            * 이때 발생하는 휴먼 에러 또한 무시할 수 없다.
* 오픈소스 작성 시 주의할 점
    * 참조: 오픈소스 라이선스 비교표
        * 이 중 제약조건이 낮고 자유도가 높은 MIT 라이선스에 대해서
            * 중요한 내용 요약
                * 이 소프트웨어를 누구라도 무상으로 제한없이 취급해도 좋다. 단 저작권 표시 및 이 허가 표시를 소프트웨어의 모든 복제물 또는 중요한 부분에 기재해야 한다.
                * 저자 또는 저작권자는 소프트웨어에 관해서 아무런 책임을 지지 않는다.
            * MIT 라이선스가 표기되어 있다는 것
                * 수정 및 배포가 자유롭다.
                * 실무 혹은 상업적으로 이용해도 된다.
                * 하지만 이 소스로 인한 피해는 전적으로 사용자가 감수해야 된다.
    * 내 앱을 만들때와는 달리 모듈 밖에서 내 코드를 어떻게 사용할지에 대한 고민도 많이 해야한다.
    * 내 프로젝트 안에서야 private, fileprivate 정도를 고민하지만 오픈 소스 라이브러리를 만드려면 다른 프로그래머가 내 라이브러리 모듈 내부의 코드를 어느 수준까지 사용하게 할지도 고려해야 한다.
    * 스위프트 언어의 접근수준에 대한 이해가 필요하다.
* 코코아팟 톺아보기
    * Swift 및 Objective-C 언어 환경 프로젝트의 의존성을 관리해주는 도구
    * 7만개 이상의 라이브러리를 보유하고 있고 300만개 이상의 애플리케이션에서 코코아팟을 활용중
    * Podfile에 사용할 라이브러리만 명시해주면 자유롭게 프로젝트에서 사용할 수 있다.
    * 코코아팟 설치하기
        * braw install cocoapods
    * 코코아팟 초기화
        * 프로젝트를 생성 후 프로젝트 폴더에서 아래 명령어를 사용한다
        * pod init
    * 프로젝트 폴더 내부에 생성된 podfile을 열어서 use_frameworks! 아래부터 설치할 pod을 명시해준다.
    * ![](https://i.imgur.com/jsMoCMz.png)
    * pod을 명시해주고 난 뒤에 파일을 저장한다. 이후 아래 명령어를 사용한다.
    * pod install 
    * 위 명령어를 실행하면 명시된 pod 라이브러리들을 프로젝트로 받아오게 된다.
    * ![](https://i.imgur.com/wSETEfY.png)
    * 이 후부터는 .xcworkspace 프로젝트 파일을 열어 작업을 해야한다.
    * .xcworkspace는 .xcodeproj의 모음, 즉 Xcode 프로젝트를 워크스페이스라는 하나의 작업공간으로 묶어놓은 단위이다.
    * 그래서 코코아팟을 통해 라이브러리를 가져오면 기존 프로젝트와 의존성을 맺어주기 위해 워크스페이스를 생성해주는 것이다.
    * Pods 프로젝트가 전역으로 관리되는 것은 아니다
    * 워크스페이스에 여러개의 프로젝트가 포함되어 있다면 podfile에서 각 프로젝트에 원하는 라이브러리 의존성을 추가하여 개별적으로 사용할 수도 있다.
    * 이제 사용하고 싶은 라이브러리를 해당 프로젝트에서 import하여 사용하면 된다.
        * import Alamofire
* Podfile?
    * 최신 버전의 라이브러리를 사용하고 싶다면 따로 pod 버전을 명시하지 않으면 된다.
        * pod ‘Alamofire’
    * 한 버전을 특정할 수도 있다.
        * pod ‘Alamofire’, ‘1.0’
    * 버전에 대하여 조건을 명시할 수도 있다.
        * > 0.1 0.1 보다 높은 버전
        * >= 0.1 0.1 이고 보다 높은 버전
        * < 0.1 0.1 보다 낮은 버전
        * <= 0.1 0.1 이고 보다 낮은 버전
    * 부등호 이외에 ~> 연산자를 활용할 수도 있다.
        * ~> 0.1.2 0.1.2 이상이지만 0.2 보다는 낮은 버전 (0.2는 포함하지 않음)
        * ~> 0.1 0.1 이상이지만 1.0 보다는 낮은 버전 (1.0은 포함하지 않음)
        * ~> 0 실질적으로 포함시키지 않는다는 의미 버전 정책에 대한 좀 더 자세한 사항은 Semantic Versioning 을 참고하자.
* Podfile.lock?
    * pod들의 버전을 계속 추적하여 기록해놓고 유지시키는 역할을 한다.
    * 유일성을 보증하는 해쉬값인 CHECKSUM이 부여된다.
        * 만약 pod버전에 하나라도 변화가 생긴다면 CHECKSUM 또한 변하게 된다.
        * 이 경우 Git을 사용할 경우 Podfile.lock이 diff로 잡히게 된다.
    * CHECKSUM이 변함없이 유지된다는 것 == 협업 환경에서 pod 버전을 모두 동일하게 사용하고 있음을 의미
    * 따라서 pod 버전을 업데이트 했다면 Podfile.lock도 같이 커밋해야한다.
* 명령어
    * pod install
        * 맨 처음 pod을 세팅하기 위해 사용한다.
        * Podfile에 pod을 추가, 수정, 삭제 할 때에도 사용한다.
    * pod update
        * 해당 팟의 업데이트된 버전이 있는지 검색한다.
        * Podfile.lock은 참조하지 않는다.
        * 이 명령어는 팟을 최신버전으로 업데이트 시켜주는 것
            * 단 podfile에 명시해둔 pod의 버전조건과 일치해야 한다.
        * 실행하면 코코아팟은 모든 현재 프로젝트의 팟에 대해 Podfile에 명시해둔 버전조건에 부합하는 최신버전으로 업데이트를 실행한다.
    * pod outdated
        * Podfile.lock에 리스트된 것 보다 새로운 버전을 가진 모든 팟을 나열해준다.
        * 이 팟들에 대해 pod update {팟이름} 을 실행한다면 업데이트가 될 것이라는 것을 의미한다.
    * pod repo update
        * /Users/{사용자이름}/.cocoapods/repos 에 있는 모든 podspec 파일을 업데이트
        * 
* 카르타고 톺아보기
    * Brew install carthage  명령어로 카르타고 설치
    * 명령어
        *  carthage update
            * 카르타고를 기반으로 모든 의존성을 갱신하고 빌드한다.
            * 특정 프레임워크만 업데이트 하기를 원한다면 뒤에 이름만 기입해주면 된다.
        * carthage bootstrap
            * Cartfile.resolved를 기반으로 모든 의존성을 갱신하고 빌드한다.
        * carthage build
            * 갱신하지 않고 모든 의존성을 빌드한다.
        * carthage outdated
            * 새로운 버전이 있는 항목들을 알려준다.
* ### 이후 남은 챕터 다시 뿌시러 가야한다...

---

- 참고링크
    - https://neph3779.github.io/til/2021.06.03-TIL/
    - https://lxxyeon.tistory.com/110
    - https://zeddios.tistory.com/1308
    - https://yagom.net/courses/open-source-library/
    
