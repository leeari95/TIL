# 211229 TCP/IP
# TIL (Today I Learned)


12월 29일 (수)

## 학습 내용
- TCP/IP 예습

&nbsp;

## 고민한 점 / 해결 방법
**[TCP/IP]**

* 인터넷이란?
    * 전 세계에 걸쳐 파일 전송 등의 데이터 통신 서비스를 받을 수 있는 컴퓨터 네트워크의 시스템
    * 인터넷을 비용을 주고 사용한다
        * 이것은 사업자가 만들어 놓은 네트워크 인프라를 사용하는 것
* TCP/IP란?
    * 인터넷에서 컴퓨터들이 서로 정보를 주고 받는데 쓰이는 프로토콜의 집합
* 계층
    * Application Layer
        * 특정 서비스를 제공하기 위해 애플리케이션끼리 정보를 주고 받을 수 있다.
        * 브라우저와 웹서버가 HTTP 요청, 응답을 통해 통신하는 것을 예로 들 수 있다.
        * HTTP, FTP, SSH, Telnet, DNS, SMTP 등과 같은 프로토콜이 사용된다
    * Transport Layer
        * 송신된 데이터를 수신측 애플리케이션에 확실히 전달하게 해준다.
        * 네트워크 통신을 하는 애플리케이션은 포트번호를 사용하게 된다.
            * 따라서 Transport Layer는 포트번호를 사용해서 애플리케이션을 찾아주는 역할을 한다.
        * TCP, UDP, RTP, RTCP 와 같은 프로토콜이 사용된다.
    * Internet Layer
        * 수신 측까지 데이터를 전달하기 위해 사용된다.
        * 송신측, 수신측 모두 IP주소를 가지고 있다.
        * IP주소를 바탕으로 올바른 목적지로 찾아갈 수 있도록 해준다.
        * IP, ARP, ICMP, RARP, OSPF 같은 프로토콜이 사용된다.
    * Network Access Layer
        * 네트워크에 직접 연결된 기기간의 데이터 전송을 도와준다.
        * 여기서는 물리적인 주소인 MAC주소를 사용한다.
        * Ethernet, PPP, Token Ring 같은 프로토콜이 사용된다.
* www.google.com을 웹브라우저에 입력하면 무슨일이 일어날까요?
    * 웹브라우저에 위 주소를 입력한다는 것은 구글 웹서버의 80포트로 아래와 같은 HTTP Request 메세지를 보내는 것이다.
    * ![](https://i.imgur.com/86md72e.png)
    * 해당 요청을 인터넷을 통해 구글서버로 전달하기 위해 우리는 패킷을 만들어야 한다.
    * 패킷에는 각 계층에 필요한 정보들이 담겨야 한다.
    * 그리고 여기서는 각 계층 별로 HTTP, TCP, IP, Ethernet 프로토콜을 사용한다고 가정하자.
    * 일단 패킷의 Application Layer에는 위에서 작성한 HTTP Request가 들어간다.
    * ![](https://i.imgur.com/vHyWDtp.png)
    * TCP 패킷의 헤더는 아래와 같이 생겼다.
    * ![](https://i.imgur.com/Ji52ep5.png)
    * 다른 부분이 많지만 우선 중요하게 볼 것은 SP와 DP다.
    * 시작 포트번호와 목적지 포트번호를 말한다.
    * 시작 포트번호는 내 컴퓨터에서 만든 소켓의 포트 번호라서 당연히 내 컴퓨터는 알고 있을 것이다.
    * 그리고 목적지 포트번호 또한 80으로 우리는 알고있다.
    * 80은 웹서버의 웰노운 포트번호다.
    * ![](https://i.imgur.com/BQRrwPs.png)
    * 다음으로는 IP 헤더에 대한 정보를 채워보자.
    * 여기서도 중요한 정보는 SA와 DA 즉, 시작 IP주소와 목적지 IP주소이다.
    * 나의 시작 IP주소는 알고있겠지만, 목적지 IP주소는 아직 모른다.
    * 지금은 www.google.com 이라는 도메인 정보만 알고 있다.
    * 그렇지만 DNS 프로토콜을 통해서 도메인 정보로 IP주소를 알아낼 수 있다.
    * ![](https://i.imgur.com/rG7YJ10.png)
    * 브라우저는 OS에게 domain에 대한 ip주소를 알고 싶다고 요청한다.
    * 그러면 OS에서 DNS서버로 요청을 보내게 된다.
    * ![](https://i.imgur.com/IAKcFA1.png)
    * 그럼 OS가 DNS서버를 어떻게 알고있을까?
    * DNS 서버 주소는 이미 컴퓨터에 등록이 되어있다.
    * 맥북의 경우 시스템 환경설정 - 네트워크에 들어가보면 내가 알고있는 DNS서버 주소를 볼 수 있다.
    * ![](https://i.imgur.com/dtxFR1e.png)
    * DNS 또한 HTTP와 같은 애플리케이션 계층 프로토콜이다.
    * 그리고 DNS는 53번 포트를 사용한다.
    * ![](https://i.imgur.com/Hqb9XiF.png)
    * DNS도 HTTP Request와 비슷하게 도메인이 담긴 쿼리를 도메인 서버로 보낸다.
    * ![](https://i.imgur.com/4ynNjrF.png)
    * 그러면 도메인 서버가 IP주소를 응답해준다.
    * DNS는 Transport Layer에서 UDP라는 프로토콜을 사용한다.
    * ![](https://i.imgur.com/xyBWUo9.png)
    * UDP는 TCP와 다르게 헤더가 간단하다. 포트번호말고 다른게 없다.
    * 그 이유는 UDP가 비연결지향형 프로토콜이기 때문이다.
    * TCP는 연결지향형 프로토콜이다.
    * 이제 DNS를 통해 성공적으로 도메인 이름에 대한 IP주소를 받아오게 되었다.
    * ![](https://i.imgur.com/Z375cPd.png)
    * ![](https://i.imgur.com/XMqsm2L.png)
    * 마지막으로 Ethernet 프로토콜에 대한 헤더를 만들어야 하는데 아직 MAC 주소를 모른다.
    * MAC주소를 어떻게 알아봐야할까?
        * MAC주소를 알아오기 전에 이전까지는 우리가 목표인 구글서버에 대한 정보가 필요했다.
        * ![](https://i.imgur.com/t0qsmsO.png)
        *  그러면 MAC 주소도 우리의 목적지인 구글 웹서버의 MAC주소가 필요할까?
        * 여기서 MAC주소는 구글의 MAC 주소 대신, 물리적으로 연결된 우리집 공유기의 MAC 주소가 필요하다.
        * ![](https://i.imgur.com/uJsN2C0.png)
        * 이 공유기를 통해 다른 네트워크와 연결이 가능하니 게이트웨이라고 부르기도 한다.
        * 따라서 게이트웨이의 IP는 이미 알고있다.
        * Netstat 명령어를 통해 확인할 수 있다.
        * ![](https://i.imgur.com/cAGkkvb.png)
        * 그럼 어떻게 IP주소로 MAC주소를 알 수 있을까?
        * IP주소로 MAC주소를 알아내기 위해서 ARP 프로토콜을 사용한다.
            * ARP란?
                * IP주소를 MAC주소로 바꾸어주는 주소해석 프로토콜
    * 자 이제 MAC 주소까지 알아냈으니 패킷이 각박한 네트워크 세계로 나갈 준비가 되었다.
    * 그런데 요청을 보내기 전에 한가지 더 봐야할게 있다.
    * 바로 TCP가 연결지향형 프로토콜이라는 점이다.
    * 그래서 TCP 프로토콜은 데이터를 전송하기 위해 송신측과 수신측이 서로 연결되는 작업이 필요하다.
    * ![](https://i.imgur.com/79Nhvhh.png)
    * 이러한 작업을 3 Way Handshaking이라고 불린다.
    * 3 Way Handshaking을 수행하기 위해서는 TCP 헤더에 표시한 플래그들이 사용된다.
    * 이러한 플래그들을 컨트롤 비트라고 부른다.
    * 3 Way Handshaking 에서는 SYN과 ACK 플래그가 사용된다.
    * ![](https://i.imgur.com/xBJ4FOx.png)
    * 클라이언트는 서버에게 접속을 요청하는 SYN 패킷을 보낸다.
    * 서버는 SYN 요청을 받고 클라이언트에게 요청을 수락한다는 ACK과 SYN 플래그가 설정된 패킷을 보낸다.
    * 클라이언트는 서버에게 다시 ACK을 보낸다.
    * 이제부터 연결이 이루어지고 데이터가 오가게 된다.
    * 이제 3 Way Handshaking으로 연결이 성립되었으니 데이터가 보내질 차례이다.
    * 내가 사용하는 컴퓨터는 Private IP를 사용하고 있다.
    * ![](https://i.imgur.com/nIa3aUV.png)
    * Private IP는 외부의 네트워크 환경에서 IP주소를 찾지 못한다.
    * 그래서 공유기를 통해 나갈 때 public ip 주소를 변환하여 나가는 작업이 필요하다.
    * 이러한 작업을 NAT(Network Adress Translation)이라고 한다.
    * 우리집 공유기를 거치고 나서 구글서버에 도착하기 위해 여러 라우터를 거쳐야 한다.
    * 라우터는 네트워크와 네트워크를 연결해주는 역할을 한다.
    * 라우터가 목적지 경로를 찾아나가는 과정을 라우팅이라고 한다.
    * ![](https://i.imgur.com/S5S7xjv.png)
    * 라우팅을 거쳐 구글서버가 연결된 라우터까지 데이터가 도착을 하면 패킷의 IP헤더에 기록된 구글 서버 IP주소를 통해 MAC 주소를 얻어와야 한다.
    * 이때 이전에 설명했던 ARP프로토콜을 사용한다. APR는 라우터가 연결된 네트워크에 브로드 캐스팅 된다.
    * 목적지 구글서버가 자신의 IP로 온 ARP요청을 받으면 MAC주소를 응답해준다. 
    * 이제 목적지 구글서버의 MAC 주소를 알았으니 데이터가 물리적으로 전달될 수 있다.
    * ARP로 IP주소를 통해 MAC주소를 얻고 목적지 구글서버에 데이터가 도착했다.
    * Internet Layer의 IP주소와 Network Access Layer의 MAC주소를 사용해서 올바른 목적지에 도착했으니 Transport Layer부터 알아보자.
    * Transport Layer의 목적지 포트번호에는 80번이 적혀있다.
    * 이것을 보고 80번 포트를 사용하고 있는 애플리케이션에게 데이터를 전달해줘야 하는 것을 알 수 있다.
    * Application Layer 까지 오면 웹 서버가 사용될 HTTP Request 데이터를 얻을 수 있게 된다.
    * 이제 서버에서 정상적으로 HTTP Request를 받고 응답을 돌려보낸다.
    * ![](https://i.imgur.com/xUMjGaZ.png)
    * “/“에 매핑된 GET요청을 처리해서 적절한 HTML을 응답해준다.
    * 실제 크롬 개발자 분석도구를 통해 확인해보면 아래와 같은 HTML을 받았다는 것을 알 수 있다.
    * ![](https://i.imgur.com/wS3ayk5.png)
    * HTTP의 요청과 응답과정이 끝나면 연결을 종료해야 한다.
    * 여기서도 TCP의 컨트롤 비트가 사용된다.
    * ![](https://i.imgur.com/HSHGWTx.png)
    * 이 단계에서는 ACK, FIN 플래그가 사용된다.
    * ![](https://i.imgur.com/731dS8b.png)
    * 클라이언트가 서버로 연결을 종료하겠다는 FIN 플래그를 전송한다.
    * 서버는 클라이언트에게 ACK 메세지를 보내고 자신의 통신이 끝날 때 까지 기다린다.
    * 서버가 통신이 끝나면 클라이언트로 FIN을 보낸다.
    * 클라이언트는 확인했다는 의미로 서버에게 ACK을 보내면 연결종료가 완료된다.
    * 총 4단계에 걸쳐 진행되고, 이것을 4-Way-Handshaking이라고 부른다.
    * ![](https://i.imgur.com/dPBXUrU.png)
    * 그런데 서버가 FIN을 보내는 과정에서 한가지 문제가 발생할 수 있다.
    * 서버가 FIN을 보내기 전에 보냈던 데이터가 FIN보다 늦게 도착할 경우에…
    * ![](https://i.imgur.com/dZpfup8.png)
    * 서버로 부터 FIN을 수신했다고 클라이언트가 바로 연결된 소켓을 닫아버리면 FIN을 보내기 전에 보낸 패킷은 영영 클라이언트가 받을 수 없게 된다. 
    * ![](https://i.imgur.com/txZ2OhB.png)
    * 그래서 클라이언트는 서버로부터 FIN 요청을 받더라도 일정시간 동안 소켓을 닫지 않고 혹시나 아직 도착하지 않은 잉여 패킷을 기다린다. 
    * 이렇게 4-Way-Handshaking 과정이 완료되어도 소켓을 닫지 않고 잉여패킷을 기다리는 상태를 TIME_WAT이라고 한다. 
* 연결지향형 프로토콜인 TCP는?
    * TCP는 신뢰할 수 있는 프로토콜이라고도 한다.
    * 요즘 세상에 우리는 엄청나게 큰 데이터를 주고 받는다. 
    * 그래서 한개의 패킷으로만 주고 받기에는 상당한 무리가 있다.
    * 그래서 데이터를 잘게 쪼개서 보내게 되고, 많은 패킷을 보내게 된다.
    * 그리고 이러한 패킷들은 엄청 복잡한 인터넷을 통해 목적지로 이동한다.
    * 이러한 복잡한 환경에서 과연 데이터들이 유실 되지않거나 올바른 순서대로 잘 도착할 수 있을까?
    * 바로 그 어려운 것을 신뢰할 수 있는 프로토콜인 TCP가 가능하게 해준다.
    * TCP는 흐름제어, 오류제어, 혼잡제어를 통해 신뢰성있는 데이터 전송을 보장할 수 있게 해준다.



---

- 참고링크
    - https://www.youtube.com/watch?v=BEK354TRgZ8
