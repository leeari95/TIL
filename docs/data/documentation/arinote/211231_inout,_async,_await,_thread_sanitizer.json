{"identifier":{"interfaceLanguage":"swift","url":"doc:\/\/AriNote\/documentation\/AriNote\/211231_inout,_async,_await,_Thread_Sanitizer"},"sections":[],"variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/documentation\/arinote\/211231_inout,_async,_await,_thread_sanitizer"]}],"hierarchy":{"paths":[["doc:\/\/AriNote\/documentation\/AriNote","doc:\/\/AriNote\/documentation\/AriNote\/Swift"]]},"primaryContentSections":[{"content":[{"type":"heading","level":1,"text":"TIL (Today I Learned)","anchor":"TIL-Today-I-Learned"},{"inlineContent":[{"type":"text","text":"12월 31일 (금)"}],"type":"paragraph"},{"type":"heading","level":2,"anchor":"%ED%95%99%EC%8A%B5-%EB%82%B4%EC%9A%A9","text":"학습 내용"},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"text":"은행창구매니저 STEP4 진행 후 PR 작성","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"inout"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"async\/await"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"Thread Sanitizer"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Thread Safe하게 코드 작성하기","type":"text"}]}]}]},{"inlineContent":[{"text":" ","type":"text"}],"type":"paragraph"},{"type":"heading","anchor":"%EA%B3%A0%EB%AF%BC%ED%95%9C-%EC%A0%90--%ED%95%B4%EA%B2%B0-%EB%B0%A9%EB%B2%95","text":"고민한 점 \/ 해결 방법","level":2},{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"text":"[inout]","type":"text"}]}]},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"inout 키워드를 사용하면 파라미터로 전달받은 값을 참조하는 줄 알았는데, 아니였다."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"값을 받아와서 대입을 하게되면, 참조해서 수정을 하는게 아니라 아예 수정한 값을 새로 덮어쓰기를 한다.","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"옵저버 프로퍼티를 inout으로 전달해주었더니 함수가 호출될 때마다 옵저버 프로퍼티의 didSet 블럭이 호출되었다.","type":"text"}]}]}],"type":"unorderedList"},{"inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"[async\/await]"}]}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Swift 5.5부터 구현된 기능"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"추가된 이유","type":"text"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Swift 개발에서 Closure 및 completion hendlers를 사용하는 비동기 프로그래밍을 많이 한다."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"많은 비동기 작업, 오류 처리, 비동기 호출 간의 제어흐름이 복잡할 때 문제가 많다."}]}]}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"많은 비동기 작업"}]},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"일련의 비동기 작업에는 deeply-nested closures가 필요하다."}]}]}],"type":"unorderedList"},{"syntax":"swift","type":"codeListing","code":["func processImageData1(completionBlock: (_ result: Image) -> Void) { loadWebResource(\"dataprofile.txt\") { dataResource in","        loadWebResource(\"imagedata.dat\") { imageResource in","            decodeImage(dataResource, imageResource) { imageTmp in","                dewarpAndCleanupImage(imageTmp) { imageResult in","                    completionBlock(imageResult)","                }","            }","        }","    }","}","","processImageData1 { image in","    display(image)","}"]},{"items":[{"content":[{"inlineContent":[{"type":"text","text":"오류처리"}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"text","text":"콜백은 오류처리를 어렵고 매우 장황하게 만든다."}],"type":"paragraph"}]}]},{"type":"codeListing","syntax":"swift","code":["\/\/ (2c) Using a `switch` statement for each ","func processImageData2c(completionBlock: (Result<Image, Error>) -> Void) { loadWebResource(\"dataprofile.txt\") { dataResourceResult in","        switch dataResourceResult {","        case .success(let dataResource):","            loadWebResource(\"imagedata.dat\") { imageResourceResult in","            switch imageResourceResult {","                case .success(let imageResource):","                decodeImage(dataResource, imageResource) { imageTmpResult in","                    switch imageTmpResult {","                        case .success(let imageTmp):","                        dewarpAndCleanupImage(imageTmp) { imageResult in","                            completionBlock(imageResult)","                        }","                        case .failure(let error):","                        completionBlock(.failure(error))","                    }","                }","                case .failure(let error):","                completionBlock(.failure(error))","            }","        } case .failure(let error):","            completionBlock(.failure(error))","        }","    }","}","","processImageData2c { result in","    switch result {","        case .success(let image): display(image)","        case .failure(let error): display(\"No image today\", error)","    }","}"]},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Swift Result가 Swift 5.0에서 추가되면서 error를 처리하는게 더 쉬워졌지만 여전히 closure 중첩 문제는 남아있다."}]}]}],"type":"unorderedList"}]},{"content":[{"inlineContent":[{"text":"비동기 호출간의 제어흐름이 복잡할 때","type":"text"}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"비동기 함수를 조건부로 실행하는 것은 고통 그 자체이다."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"예를 들어 이미지를 얻은 후 swizzle 해야한다고 할 때","type":"text"}]},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"이미지가 있으면 바로 swizzle"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"이미지가 없으면 decode후 swizzle"}],"type":"paragraph"}]}],"type":"unorderedList"}]}]},{"type":"codeListing","syntax":"swift","code":["func processImageData3(recipient: Person, completionBlock: (_ result: Image) -> Void) {","    let swizzle: (_ contents: Image) -> Void = {","      \/\/ ... continuation closure that calls completionBlock eventually","    }","    if recipient.hasProfilePicture {","        swizzle(recipient.profilePicture)","    } else {","        decodeImage { image in","            swizzle(image)","        }","    }","}"]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"그래서 위와같은 코드가 필요하다.","type":"text"}]}]},{"content":[{"inlineContent":[{"text":"이 함수를 구조화 하는 방법은 위 코드와 같이 completion handler에서 swizzle 코드를 작성하는 것이다.","type":"text"}],"type":"paragraph"}]}]},{"type":"codeListing","syntax":"swift","code":["func processImageData3(recipient: Person, completionBlock: (_ result: Image) -> Void) {","    let swizzle: (_ contents: Image) -> Void = { \/\/ ... continuation closure that calls completionBlock eventually ✅✅   ","    }","    if recipient.hasProfilePicture {","        swizzle(recipient.profilePicture)","    } else {","        decodeImage { image in","            swizzle(image)","        }","    }","}"]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"이 패턴은 함수의 자연스러운 하향식 구성을 반전시킨다."}]}]},{"content":[{"inlineContent":[{"text":"swizzle closure가 completion handler에서 사용되므로 capture에 대해 신중하게 생각해야 한다.","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"조건부로 실행되는 비동기 함수의 수가 증가함에 따라 문제는 더욱 악화되고 본질적으로 반전된 pyramid of doom을 생성시킨다."}]}]}]}]}],"type":"unorderedList"},{"syntax":"swift","code":["func processImageData4a(completionBlock: (_ result: Image?, _ error: Error?) -> Void) {","    loadWebResource(\"dataprofile.txt\") { dataResource, error in","         guard let dataResource = dataResource else {","            return \/\/ ⚠️ <- forgot to call the block","        } loadWebResource(\"imagedata.dat\") { imageResource, error in","            guard let imageResource = imageResource else {","                 return \/\/ ⚠️ <- forgot to call the block","                 } ...","        }","    }","}"],"type":"codeListing"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"실수하기 쉬워진다."}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"completion block을 호출하지 않고 그냥 return하고 잊어버리면 디버깅 하기가 어려워진다.","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"내가 만약 잊지 않고 completion block을 호출했다고 치면"}],"type":"paragraph"}]}]},{"type":"codeListing","code":["func processImageData4b(recipient:Person, completionBlock: (_ result: Image?, _ error: Error?) -> Void) {","    if recipient.hasProfilePicture {","        if let image = recipient.profilePicture {","            completionBlock(image) \/\/ ⚠️ <- forgot to return after calling the block","        }","    } ...","}"],"syntax":"swift"},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"text","text":"completion block을 호출하고 나서 return 호출하는 것을 까먹을 수도 있다."}],"type":"paragraph"},{"items":[{"content":[{"inlineContent":[{"text":"guard는 return을 하지 않으면 컴파일 에러를 주긴 하지만 항상 guard를 쓰는건 아니니까…","type":"text"}],"type":"paragraph"}]}],"type":"unorderedList"}]}]}]}],"type":"unorderedList"}]},{"content":[{"inlineContent":[{"type":"text","text":"해결"}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"위와 같은 문제를 해결하기 위해 async-await proposal은 Swift에 코루틴(coroutine) 모델을 도입하게 된다."}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"비동기 함수의 semantics 정의와 동시성을 제공하지는 않는다.","type":"text"}]}]}]}]}]}]},{"content":[{"inlineContent":[{"text":"비동기 함수(async\/await)를 사용하면?","type":"text"}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"text","text":"비동기 코드를 마치 동기 코드인 것처럼 작성할 수 있게 된다."}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"프로그래머가 동기 코드에서 사용할 수 있는 동일한 언어 구조를 최대한 활용할 수 있게 된다."}]}]}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"자연스럽게 코드의 의미 구조를 보존할 수 있다."}]},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"text":"언어에 대한 최소한 3가지 교차 개선에 필요한 정보를 제공…? 이게 뭔소리야","type":"text"}],"type":"paragraph"}]}]}]},{"content":[{"inlineContent":[{"text":"비동기 코드의 성능 향상","type":"text"}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"better performance for asynchronous code"}]}]}]}]},{"content":[{"inlineContent":[{"text":"코드를 디버깅, 프로파일링 및 탐색하는 동안 보다 일관된 경험을 제공하기 위한 더 나은 도구","type":"text"}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"better tooling to provide a more consistent experience while debugging, profiling and exploring code"}]}]}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"작업 우선 순위 및 취소와 같은 동시성 기능을 위한 기반","type":"text"}]},{"items":[{"content":[{"inlineContent":[{"type":"text","text":"a foundation for future concurrency features like task priority and cancellation"}],"type":"paragraph"}]}],"type":"unorderedList"}]}]}]}],"type":"unorderedList"},{"type":"thematicBreak"},{"type":"paragraph","inlineContent":[{"inlineContent":[{"type":"text","text":"[코드에서 경쟁 상태를 확인하는 방법]"}],"type":"strong"}]},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"text":"Xcode에서 ..","type":"text"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"Product > scheme > editScheme > Run > Diagnostics > Thread Sanitizer"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Thread Sanitizer 이걸 체크하면 빌드를 돌리고 나서 thread safe 하지 않은 상황이 발생할 수 있는 가능성을 엑스코드에서 체크해준다.","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"하지만 사용해보니 완벽하게 체크해주는 건 아닌 것 같다.[?] 그냥 도와주는 기능이라고 생각하고 사용해야할 것 같다."}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"identifier":"https:\/\/i.imgur.com\/ERrHYab.png","type":"image"}],"type":"paragraph"}]}],"type":"unorderedList"}]}]},{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"text":"[Thread Safe하게 코드를 작성하려면?]","type":"text"}]}]},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"text","text":"공유자원을 읽고 쓰는 작업을 Thread safe하게 Shemaphore를 사용해서 하나의 thread만 접근 할 수 있도록 하는 방법이 있다."}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"하지만 이 방법은 완벽하게 제어하기는 무리가 있다. 오히려 공유자원을 lock으로 처리하다가 교착 상황 발생할 가능성이 높다고 한다."}]}]}]}]},{"content":[{"inlineContent":[{"text":"Serial Queue sync로 보내서 처리하는 방법도 있다.","type":"text"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"그러면 들어온 task에 순서가 생기기 때문에 다수의 스레드에서 동시에 값을 접근하지 못하게 하는 상황이 된다.","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"sync로 사용하는 이유는 Serial queue로 보낸 작업을 기다림으로써 공유자원의 제대로 된 값을 얻기 위함이다."}]}]}],"type":"unorderedList"}]}]},{"type":"thematicBreak"},{"items":[{"content":[{"inlineContent":[{"text":"참고링크","type":"text"}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"https:\/\/zeddios.tistory.com\/1230","type":"text"}]}]},{"content":[{"inlineContent":[{"text":"https:\/\/github.com\/apple\/swift-evolution\/blob\/main\/proposals\/0296-async-await.md","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"https:\/\/ios-development.tistory.com\/618","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"https:\/\/sujinnaljin.medium.com\/ios-%EC%B0%A8%EA%B7%BC%EC%B0%A8%EA%B7%BC-%EC%8B%9C%EC%9E%91%ED%95%98%EB%8A%94-gcd-12-c06b599fe7f5","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"https:\/\/docs.swift.org\/swift-book\/LanguageGuide\/Concurrency.html"}]}]}]}]}],"type":"unorderedList"}],"kind":"content"}],"schemaVersion":{"major":0,"patch":0,"minor":3},"kind":"article","metadata":{"modules":[{"name":"Ari's Notes"}],"roleHeading":"Article","role":"article","title":"211231 inout, async, await, Thread Sanitizer"},"references":{"doc://AriNote/documentation/AriNote":{"kind":"symbol","type":"topic","identifier":"doc:\/\/AriNote\/documentation\/AriNote","abstract":[{"type":"codeVoice","code":"Today I Learned"}],"url":"\/documentation\/arinote","title":"Ari's Notes","role":"collection"},"doc://AriNote/documentation/AriNote/Swift":{"identifier":"doc:\/\/AriNote\/documentation\/AriNote\/Swift","role":"collectionGroup","abstract":[{"type":"text","text":"언어 공부"}],"kind":"article","title":"Swift","url":"\/documentation\/arinote\/swift","type":"topic"},"https://i.imgur.com/ERrHYab.png":{"identifier":"https:\/\/i.imgur.com\/ERrHYab.png","variants":[{"url":"https:\/\/i.imgur.com\/ERrHYab.png","traits":["1x","light"]}],"alt":null,"type":"image"}}}