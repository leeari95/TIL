{"metadata":{"modules":[{"name":"Ari's Notes"}],"role":"article","title":"211223 POP, delegate","roleHeading":"Article"},"variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/documentation\/arinote\/211223_pop,_delegate"]}],"schemaVersion":{"major":0,"patch":0,"minor":3},"hierarchy":{"paths":[["doc:\/\/AriNote\/documentation\/AriNote","doc:\/\/AriNote\/documentation\/AriNote\/CS"]]},"primaryContentSections":[{"kind":"content","content":[{"level":1,"text":"TIL (Today I Learned)","type":"heading","anchor":"TIL-Today-I-Learned"},{"type":"paragraph","inlineContent":[{"type":"text","text":"12월 23일 (목)"}]},{"anchor":"%ED%95%99%EC%8A%B5-%EB%82%B4%EC%9A%A9","level":2,"text":"학습 내용","type":"heading"},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"text":"은행창구매니저 STEP 2 진행","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"Protocol Oriented Programming 활동학습"}],"type":"paragraph"}]}]},{"type":"paragraph","inlineContent":[{"type":"text","text":" "}]},{"text":"고민한 점 \/ 해결 방법","level":2,"anchor":"%EA%B3%A0%EB%AF%BC%ED%95%9C-%EC%A0%90--%ED%95%B4%EA%B2%B0-%EB%B0%A9%EB%B2%95","type":"heading"},{"inlineContent":[{"inlineContent":[{"type":"text","text":"[Protocol Oriented Programming]"}],"type":"strong"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"상속은 기능을 추가, 확장을 위한 목적으로 필요하지만 다중상속이 불가능하다는 한계가 있다.","type":"text"}]},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"text","text":"또한 클래스에서만 가능하다."}],"type":"paragraph"}]}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"프로토콜 지향 프로그래밍으로 객체지향 프로그래밍의 다중상속이 불가능하다는  단점을 극복할 수 있다."}]},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"또한 프로토콜은 클래스 외에 구조체나 열거형에도 채택을 해줄 수 있다.","type":"text"}]}]}],"type":"unorderedList"}]},{"content":[{"inlineContent":[{"text":"protocol에 extension을 구현하면 기본구현을 제공한다.","type":"text"}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"하지만 타입에서 프로토콜의 정의 부분을 다시 재구현 해준다면 타입에서의 구현이 높은 우선 순위이다.","type":"text"}]}]}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"성능을 위한다면 value type을 주로 사용하고, 꼭 필요한 경우에는 클래스를 활용하면 될 것 같다."}]},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"프로토콜 지향 프로그래밍이 확실히 객체지향보다 장점이 많지만 어떤 것이 최고다 라고 판단할 수는 없다. 상황에 따라 적합하게 활용하는 것이면 충분할 것 같다.","type":"text"}]},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"text","text":"프로토콜을 채택한 클래스를 상속받는다면 부모 클래스가 채택한 프로토콜과 부모가 가지고 있는 기능 모두를 사용할 수 있게 된다. 이후 다른 프로토콜도 추가로 채택할 수도 있다."}],"type":"paragraph"}]}]}]},{"content":[{"inlineContent":[{"type":"text","text":"장점도 많고 깔끔하고 안전해보이지만 그렇다고 남발한다면  아무곳에나 프로토콜을 가져다 쓰게 될 수도 있다."}],"type":"paragraph"}]}],"type":"unorderedList"}]}],"type":"unorderedList"},{"type":"thematicBreak"},{"type":"paragraph","inlineContent":[{"inlineContent":[{"type":"text","text":"[은행 창구 매니저 프로젝트를 하면서 고민했던 점]"}],"type":"strong"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"모델에서 "},{"type":"codeVoice","code":"print()"},{"type":"text","text":"해주는 부분을 분리할 수는 없을까?"}]}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"delegate 패턴을 활용하여 분리해보는 것을 도전해보자 !!"}]}]}]}]},{"content":[{"type":"paragraph","inlineContent":[{"inlineContent":[{"type":"codeVoice","code":"delegate 패턴"},{"type":"text","text":"을 통해서 분리해주었지만 약간 의문점이 생겼다."}],"type":"strong"}]},{"items":[{"content":[{"inlineContent":[{"text":"모델들을 print의 역할을 가져간 타입들이 참조를 해야하기 때문에 기존에 struct에서 class로 변경되었다.","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"역할이 확실히 분리는 되었지만 코드의 모양새가 약간 찝찝하다고 해야하나.."}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"값타입이 아닌 참조타입들이라서 추후 retain count 추적 비용이 발생할 것 같다는 걱정이 들었다."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"이니셜라이저에 기본값을 주었었는데, main에서 한꺼번에 값을 할당해주기 위해 모조리 제거해주었다.","type":"text"}]}]}],"type":"unorderedList"}]},{"content":[{"inlineContent":[{"type":"text","text":"delegate 패턴을 구현하기 위한 위와 같은 필요에 의한 수정들이 과연 적절한 것일까?"}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"이 부분은 리뷰어에게 조언을 받아보기로 하였다.","type":"text"}]}]}]}]}],"type":"unorderedList"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"느낀점"}]}]},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"STEP 2에서 이러한 고민들이 좋았다고 느껴졌다."}]},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"text":"타입 및 일반화 추상화에 더해져서 SOLID까지 고려하여 고민해볼 수 있다는 부분!","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"내가 느끼기에는 우리의 코드는 단일 책임 원칙을 잘 지켜낸 것 같다[?]","type":"text"}]}]}]}]},{"content":[{"inlineContent":[{"text":"기존에 프로젝트 진행시 요구사항에서 오버 엔지니어링 하지않도록 딱 요구사항만 지켰다면, 이번 프로젝트에서는 요구사항에서 한발 더 나아가 깊게 고민했던 것 같아서, 이런 고민을 같이 깊게 나눠준 허황에게 고마웠다.","type":"text"}],"type":"paragraph"}]}],"type":"unorderedList"}]}]}]}],"identifier":{"url":"doc:\/\/AriNote\/documentation\/AriNote\/211223_POP,_delegate","interfaceLanguage":"swift"},"sections":[],"kind":"article","references":{"doc://AriNote/documentation/AriNote":{"kind":"symbol","type":"topic","identifier":"doc:\/\/AriNote\/documentation\/AriNote","abstract":[{"type":"codeVoice","code":"Today I Learned"}],"url":"\/documentation\/arinote","title":"Ari's Notes","role":"collection"},"doc://AriNote/documentation/AriNote/CS":{"type":"topic","role":"collectionGroup","url":"\/documentation\/arinote\/cs","kind":"article","title":"CS","identifier":"doc:\/\/AriNote\/documentation\/AriNote\/CS","abstract":[{"type":"text","text":"Computer Science"}]}}}