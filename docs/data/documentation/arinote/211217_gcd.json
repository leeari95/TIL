{"kind":"article","primaryContentSections":[{"kind":"content","content":[{"level":1,"text":"TIL (Today I Learned)","type":"heading","anchor":"TIL-Today-I-Learned"},{"type":"paragraph","inlineContent":[{"type":"text","text":"12월 17일 (금)"}]},{"type":"heading","text":"학습 내용","anchor":"%ED%95%99%EC%8A%B5-%EB%82%B4%EC%9A%A9","level":2},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"GCD를 반복학습…"}]},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"앨런의 동시성 프로그래밍 강의"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"야곰닷넷 동시성 프로그래밍 강의"},{"text":" ","type":"text"},{"type":"text","text":" "}],"type":"paragraph"}]}],"type":"unorderedList"}]}],"type":"unorderedList"},{"type":"heading","anchor":"%EA%B3%A0%EB%AF%BC%ED%95%9C-%EC%A0%90--%ED%95%B4%EA%B2%B0-%EB%B0%A9%EB%B2%95","text":"고민한 점 \/ 해결 방법","level":2},{"inlineContent":[{"type":"strong","inlineContent":[{"text":"[GCD 1]","type":"text"}]}],"type":"paragraph"},{"items":[{"content":[{"inlineContent":[{"type":"text","text":"스레드 == 일하는 녀석들"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"왜 스크롤을 내렸을 때 버벅였나?"}]},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"text","text":"여러개의 스레드가 있지만 한개의 스레드에서만 일을 시켰기 때문이다."}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"다른 스레드에 분산시켜서 처리하지 못했기 때문이다."}]}]}]}]},{"content":[{"inlineContent":[{"text":"어떻게 다른 스레드로 작업을 분산시킬 수 있을까?","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"작업을 어떻게 다른 스레드에서 동시에 일을 하게 할 수 있을까?"}],"type":"paragraph"},{"items":[{"content":[{"inlineContent":[{"type":"text","text":"이것이 바로 동시성 프로그래밍이다."}],"type":"paragraph"}]}],"type":"unorderedList"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"iOS 프로그래밍에서는 작업을 대기 행렬(Queue)에 보내기만 하면 알아서 OS가 다른 스레드로 분산처리를 하고 있다.","type":"text"}]}]},{"content":[{"inlineContent":[{"text":"Queue는 항상 선입선출로 동작한다 (FIFO)","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"작업이 먼저 배치 됐다고 해서 그 작업이 먼저 끝난다는 개념은 아니다.","type":"text"}]}]},{"content":[{"inlineContent":[{"text":"우리가 할일","type":"text"}],"type":"paragraph"},{"items":[{"content":[{"inlineContent":[{"text":"작업을 Queue로 보내는 코드를 배우자","type":"text"}],"type":"paragraph"}]}],"type":"unorderedList"}]}],"type":"unorderedList"},{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"[GCD2]"}]}]},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"iOS 프로그래밍에서는 Queue를 표현하는 것에는 크게 두가지가 있다.","type":"text"}]},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"text":"GCD (DispathQueue)","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"Operation"}],"type":"paragraph"}]}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"직접적으로 스레드를 관리하지 않고 Queue만 만들어서 그 안에 작업을 넣기만 하면 된다.","type":"text"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"시스템이 알아서 스레드에 작업을 분산하여 스레드를 관리한다.","type":"text"}]},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"text","text":"직접 스레드를 생성하는 것은 하드웨어나 일의 부하(load)와 같은 시스템에 대한 지식없이 사용하면 오히려 앱이 느려질 수 있다."}],"type":"paragraph"}]}]}]}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"스레드보다 더 높은 레벨\/차원에서 일을 한다고 보면 된다."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"쉽게 다른 스레드에서 (오래걸리는) 작업들이 “비동기적으로 동작”하도록 만들어준다. (네트워크 관련)","type":"text"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"어떤 API들은 내부적으로 다른 스레드에서 비동기적으로 실행되도록 설계되어있다."}]}]}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"어떻게 코드로 Queue에 보낼까?","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"image","identifier":"https:\/\/i.imgur.com\/ZyqjbsI.png"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"DispatchQueue.global().async { }","type":"text"}]},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"text":"큐에 보낼거야, 글로벌큐에, 비동기적으로","type":"text"}],"type":"paragraph"}]}]}]}],"type":"unorderedList"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"아래처럼도 가능하다."}]}]},{"content":[{"inlineContent":[{"identifier":"https:\/\/i.imgur.com\/CSuoGv7.png","type":"image"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"클로저에 들어가는 작업은 한 단위이다."}]}]},{"content":[{"inlineContent":[{"type":"image","identifier":"https:\/\/i.imgur.com\/rJa10vZ.png"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"작업의 단위 == “하나의 클로저” 안에 보내는 작업 자체가 묶이는 개념이다."}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"image","identifier":"https:\/\/i.imgur.com\/XQiK8YH.png"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"GCD와 Operation의 차이"}]},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"GCD = 디스패치큐","type":"text"}]},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"간단한 일"}]}]},{"content":[{"inlineContent":[{"text":"함수를 사용하는 작업","type":"text"}],"type":"paragraph"}]}],"type":"unorderedList"}]},{"content":[{"inlineContent":[{"type":"text","text":"Operation = 오퍼레이션 큐"}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"복잡한 일"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"데이터와 기능을 캡슐화한 객체"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"취소, 순서지정, 일시중지(상태추적)","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"GCD를 기반으로 하고 있다."}],"type":"paragraph"}]}]}]}],"type":"unorderedList"}]},{"content":[{"inlineContent":[{"text":"프로젝트의 효율성, 사례 적합성 등을 고려하여 둘중에 하나를 선택해서 사용하면 된다.","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Operation같은 경우는 객체이기 때문에 한번 만들어놓으면 재사용 가능성이 있다는 장점이 있다."}]}]}],"type":"unorderedList"},{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"[GCD 3]"}]}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"identifier":"https:\/\/i.imgur.com\/vhjSsha.png","type":"image"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"비동기(Async)"}]},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"text":"코드를 통해서 Queue로 작업을 보낸다.","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"작업을 보내고 나서 바로 즉시 리턴하는 개념이 비동기다."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"즉 작업을 보내고 보냈다가 그 작업이 완료되는 것을 기다리지 않고 스레드로 돌아오는 것"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"일을 시작은 시키고 작업이 끝날 때까지 기다리지 않는다. = 메인스레드가 다른 일을 시작할 수 있다."}]}]}]}]},{"content":[{"type":"paragraph","inlineContent":[{"identifier":"https:\/\/i.imgur.com\/670zQzv.png","type":"image"}]}]},{"content":[{"inlineContent":[{"text":"동기(sync)","type":"text"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"작업을 보내고 해당 작업이 다 끝날 때까지 기다려주는 것 = 메인스레드가 작업이 끝날 때 까지 기다려야한다."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"1번 Task가 작업이 마칠 때까지 기다릴거야 라는 개념.","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"동기적으로 코드를 짜게 되면 Queue에 보내는 것이 의미가 없다."}],"type":"paragraph"},{"items":[{"content":[{"inlineContent":[{"type":"text","text":"따라서 동기적으로 보내는 코드를 짜면 실질적으로는 메인스레드에서 일을 한다."}],"type":"paragraph"}]}],"type":"unorderedList"}]}],"type":"unorderedList"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"따라서 Queue에 작업을 보낼 때 보통은 대부분 async를 사용한다."}]},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"text":"결국에는 우리는 기존에 오래 걸리던 작업을 다른 스레드로 보내고 싶은거고 그렇게 다른 스레드로 보낸 작업을 기다리지 않고 다른 일들을 하고 싶은 것이다.","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"따라서 async 메소드를 사용하게 된다."}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"다만 sync가 필요한 경우도 있다."}]}]}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"요약","type":"text"}]},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"text","text":"비동기는 작업을 다른 스레드에 시킨 후 안기다려도 다음 작업을 할 수 있고, 동기는 기다렸다가 다음 작업을 진행한다."}],"type":"paragraph"}]}]}]},{"content":[{"inlineContent":[{"type":"text","text":"비동기라는 개념이 일반적으로 필요한 이유는 뭘까?"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"대부분은 서버와의 통신(네트워크 작업) 때문이다.","type":"text"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"네트워크와 관련된 작업들은 내부적으로 비동기적으로 구현된다."}]}]},{"content":[{"inlineContent":[{"text":"네트워크 상황에 따라서 그 작업이 얼마나 걸릴지 알 수 없다.","type":"text"}],"type":"paragraph"}]}]}]}],"type":"unorderedList"}]},{"content":[{"type":"paragraph","inlineContent":[{"identifier":"https:\/\/i.imgur.com\/cGBjDZU.png","type":"image"}]}]},{"content":[{"inlineContent":[{"text":"예시로 URLSession 같은 경우에는 사용하는 것만으로도 내부적으로 알아서 다른 스레드에 대해서 이미 일을 하고 있다.","type":"text"}],"type":"paragraph"}]}]},{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"text":"[GCD 4]","type":"text"}]}]},{"inlineContent":[{"inlineContent":[{"type":"text","text":"[Serial(직렬) vs Concurrent(동시)]"}],"type":"strong"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"큐가 가진 특성에 대해서 이야기 해보자.","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"그림으로 이해해보기","type":"text"}]}]},{"content":[{"inlineContent":[{"identifier":"https:\/\/i.imgur.com\/Ufmi1jn.png","type":"image"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"Serial Queue"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"작업을 큐에 배치시키면 한개의 스레드에만 보내는 큐다."}]}]}],"type":"unorderedList"}]},{"content":[{"inlineContent":[{"type":"image","identifier":"https:\/\/i.imgur.com\/S8LqcTq.png"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Concurrent Queue","type":"text"}]},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"text","text":"여러개의 스레드로 작업을 배치시키는 큐다."}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"몇개의 스레드로 분산할지는 시스템이 알아서 결정하고, 다만 여러개의 스레드로 분산 처리를 한다."}],"type":"paragraph"}]}]}]},{"content":[{"inlineContent":[{"text":"요약","type":"text"}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"text":"직렬큐는 메인에서 분산처리 시킨 작업을 다른 한개의 스레드에서 처리하는 큐","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"동시큐는 메인에서 분산처리 시킨 작업을 다른 여러갸의 스레드에서 처리하는 큐"}],"type":"paragraph"}]}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"동시큐가 무조건 좋아보이는 것 같은데 직렬큐는 왜 필요할까?","type":"text"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"직렬큐는 순서가 중요한 작업을 할 때 사용한다.","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"동시큐는 각자 독립적이지만 유사한 여러개의 작업을 처리할 때 사용한다."}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"text":"독립적이지만 유사한 여러개의 작업?","type":"text"}],"type":"paragraph"}]}]}]}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"image","identifier":"https:\/\/i.imgur.com\/4LCoi3i.png"},{"type":"text","text":" "},{"type":"text","text":"* 예시로 테이블뷰 셀 3개가 독립적이지만 유사한 작업들이다."}]}]}],"type":"unorderedList"},{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"[GCD와 Operation의 차이]"}]}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Operation은 GCD 기반으로 만들어져있다."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"GCD와 다르게 Operation은 취소 \/ 순서지정 \/ 일시중지 등 여러가지 기능들이 있다.","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"프로젝트 효율성, 사례 적합성 등을 고려하여 GCD나 Operation을 선택해 사용하면 될 것 같다.","type":"text"}]}]}]},{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"[언제 Operation이 필요할까?]"}]}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"identifier":"https:\/\/i.imgur.com\/hGbb0Zv.png","type":"image"}]}]},{"content":[{"inlineContent":[{"text":"아주 빠르게 스크롤을 내렸을 때","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"identifier":"https:\/\/i.imgur.com\/90ykKbI.png","type":"image"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"이미 지나간 영역을 표시할 필요가 있을까?"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"이미지 다운로드 하는 작업을 취소하고 싶다."}]}]}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"이런 상황에 사용하는 것이 Operation Queue이다.","type":"text"}]}]}]},{"type":"thematicBreak"},{"inlineContent":[{"type":"strong","inlineContent":[{"text":"[야곰닷넷 동시성 프로그래밍]","type":"text"}]}],"type":"paragraph"},{"inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"[Main Thread]"}]}],"type":"paragraph"},{"items":[{"content":[{"inlineContent":[{"type":"text","text":"앱의 기본이 되는 스레드"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"앱의 생명주기와 같은 생명주기를 가지는, 앱이 실행되는 동안에는 늘 메모리에 올라와있는 기본스레드"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"즉 메인 스레드가 멈추는 것은 앱이 멈추는 것이며 메인스레드가 존재하지 않으면 앱은 동작할 수 없다."}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"메인 스레드는 늘 메모리에 올라온 상태로 존재한다."}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"메인 스레드에서부터 필요한 만큼의 스레드가 파생되는 것"}]},{"items":[{"content":[{"inlineContent":[{"type":"text","text":"이때 파생되는 스레드들은 자신이 담당하는 작업이 처리되면 메모리에서 사라지게 된다."}],"type":"paragraph"}]}],"type":"unorderedList"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"메인 스레드는 그림자 분신술의 실체인 셈","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"특징"}]},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"text","text":"전역적으로 사용 가능"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"global 스레드들과는 다르게 Run Loop가 자동으로 설정되고 실행된다.","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"메인 스레드에서 동작하는 Run Loop를 Main Run Loop라고 한다.","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"UI 작업은 메인 스레드에서만 작업할 수 있다.","type":"text"}]}]}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"main Queue를 sync로 직접적으로 호출하면 deadlock 상태에 빠지게 된다.","type":"text"}]},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"작업이 끝나기를 기다리는 sync의 특성 때문이다.","type":"text"}]}]},{"content":[{"inlineContent":[{"text":"Main 스레드는 sync의 코드 블록이 수행되기를 기다려야 하는데, 이 때 sync 코드 블록 역시 멈춰버리는 것이다.","type":"text"}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"text","text":"Main 스레드에서 실행되고 있던 코드이기 때문이다."}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"따라서 아무것도 실행되지 못하고 main 스레드는 sync가 끝나기를, sync는 main 스레드의 block-wait이 끝나기를 기다리는 상태가 되어버린다."}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"이러한 현상은 main Queue이기 때문에 발생하는 현상이다.","type":"text"}],"type":"paragraph"}]}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Main.sync를 호출하는 방법은 아래 예시처럼 main 스레드에서 호출하지 않으면 된다.","type":"text"}]}]}],"type":"unorderedList"}]}],"type":"unorderedList"},{"type":"codeListing","code":["import Foundation","","DispatchQueue.global().async {","    DispatchQueue.main.sync {","        for _ in 1...5 {","            print(\"😀😀😀😀😀\")","            sleep(1)","        }","    }","}","","for _ in 1...5 {","    print(\"🥶🥶🥶🥶🥶\")","    sleep(2)","}"],"syntax":"swift"},{"inlineContent":[{"inlineContent":[{"text":"[DispatchWorkItem]","type":"text"}],"type":"strong"}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"text","text":"코드 블럭을 캡슐화할 수 있다."}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"타입을 명시하는 동시에 더 직관적인 코드를 작성할 수 있다.","type":"text"}]}]}]},{"syntax":"swift","type":"codeListing","code":["import Foundation","","let red = DispatchWorkItem {","    for _ in 1...5 {","        print(\"🥵🥵🥵🥵🥵\")","        sleep(1)","    }","}","","let yellow = DispatchWorkItem {","    for _ in 1...5 {","        print(\"😀😀😀😀😀\")","        sleep(1)","    }","}","","let blue = DispatchWorkItem {","    for _ in 1...5 {","        print(\"🥶🥶🥶🥶🥶\")","        sleep(2)","    }","}","","DispatchQueue.main.async(execute: yellow)","DispatchQueue.global().sync(excute: blue)"]},{"inlineContent":[{"inlineContent":[{"text":"[asyncAfret]","type":"text"}],"type":"strong"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"async 메소드를 원하는 시간에 호출해줄 수 있는 메소드다."},{"type":"text","text":" "},{"type":"text","text":"DispatchQueue.global().asyncAfter(deadline: .now() + 5, execute: yellow)"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"위 코드는 지금으로부터 5초후에 yellow라는 DispatchWorkItem을 실행시킨다는 코드다."}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"Execute 파라미터 대신 직접 코드 블럭을 구현해도 된다.","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"deadline 대신에 walldeadline이라는 파라미터를 사용해줄 수도 있는데, qallDeadline은 시스템(기기)의 시간을 기준으로 카운트 하는 것이다."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"즉 deadline은 스톱워치로 측정하듯이 5초를 카운트해서 작업이 시작되고 wallDeadline은 지금 5시니까 5시 5초에 작업을 시작해야지와 같이 작업을 수행하는 것"}]}]}],"type":"unorderedList"},{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"[asyncAndWait]"}]}]},{"items":[{"content":[{"inlineContent":[{"type":"text","text":"비동기 작업이 끝나는 시점을 기다릴 수 있다."}],"type":"paragraph"}]}],"type":"unorderedList"},{"type":"thematicBreak"},{"type":"aside","style":"note","name":"Note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"1️⃣ sync와 async의 차이는 무엇인가요?"}]}]},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"text","text":"기다리는 것, 기다리지 않는 것"}],"type":"paragraph"}]}]},{"style":"note","name":"Note","content":[{"inlineContent":[{"text":"2️⃣ async와 concurrent는 구분되는 개념이라고 했습니다. 각각을 설명해보세요.","type":"text"}],"type":"paragraph"}],"type":"aside"},{"items":[{"content":[{"inlineContent":[{"text":"Async","type":"text"}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"작업을 다른 스레드에 시킨 후 안기다려도 다음 작업을 할 수 있다"}]}]}]}]},{"content":[{"inlineContent":[{"type":"text","text":"Concurrent Queue"}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"text","text":"여러개의 스레드로 작업을 배치시키는 큐"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"몇개의 스레드로 분산할지는 시스템이 알아서 결정하고 다만 여러개의 스레드로 분산 처리를 한다."}]}]}]}]}],"type":"unorderedList"},{"content":[{"inlineContent":[{"text":"3️⃣ DispatchQueue에서 serial 큐와 main 큐는 같은 것인가요?","type":"text"}],"type":"paragraph"}],"style":"note","name":"Note","type":"aside"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"main이 기본적으로 serial 큐인 것인 부분 말고는 다르다."}]}]}],"type":"unorderedList"},{"type":"aside","style":"note","name":"Note","content":[{"type":"paragraph","inlineContent":[{"text":"4️⃣ DispatchQueue에서 main과 global()의 차이는 무엇인가요?","type":"text"}]}]},{"items":[{"content":[{"inlineContent":[{"text":"main은 앱의 기본이 되는 스레드이다.","type":"text"}],"type":"paragraph"},{"items":[{"content":[{"inlineContent":[{"type":"text","text":"앱이 실행되는 동안에 늘 메모리에 올라와 있는 기본 스레드"}],"type":"paragraph"}]}],"type":"unorderedList"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"global은 Concurrent Queue라서 여러개의 스레드가 존재한다."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"따라서 화면처리를 하는게 아니라면 꼭 main에다 넣을 필요 없다. global이나 다른 스레드에 넣어줘도 된다."}]}]}],"type":"unorderedList"},{"name":"Note","type":"aside","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"5️⃣ main 스레드는 어떤 특징을 가지고 있나요?"}]}],"style":"note"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"전역적으로 사용이 가능하다.","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"global 스레드들과는 다르게 Run Loop가 자동으로 설정되고 실행된다."}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"UI 작업은 메인 스레드에서만 작업할 수 있다.","type":"text"}],"type":"paragraph"}]}]},{"name":"Note","content":[{"inlineContent":[{"type":"text","text":"6️⃣ Serial에서 async는 어떻게 동작하나요?"}],"type":"paragraph"}],"type":"aside","style":"note"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"쌓인 순서대로 작업이 처리된다.","type":"text"}]}]}]},{"name":"Note","content":[{"inlineContent":[{"type":"text","text":"7️⃣ serial 큐에서 sync로 작업을 처리하면 어떻게 될까요?"}],"type":"paragraph"}],"style":"note","type":"aside"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"각각의 작업이 끝나기를 기다리고 다음 작업을 처리한다."}]}]}],"type":"unorderedList"},{"style":"note","type":"aside","name":"Note","content":[{"inlineContent":[{"text":"8️⃣ main.sync를 사용하면 어떻게 되나요? 그 이유는 무엇인가요?","type":"text"}],"type":"paragraph"}]},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"text","text":"deadlock 상태에 빠지게 된다."}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"이유는 작업이 끝나기를 기다리는 sync의 특성 때문이다.","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"sync는 코드 블럭이 처리되기 전까지 다음 코드로 넘어가지 않는 것을 확인했는데 이러한 상황을 Block-wait이라고 한다.","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"Main.sync를 호출하게 되면 main 스레드는 sync의 코드 블럭이 수행되기를 기다려야 한다."}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"sync는 main 스레드의 Block-wait이 끝나기를 기다리는 상태가 된다."}]}]}]},{"name":"Note","type":"aside","style":"note","content":[{"type":"paragraph","inlineContent":[{"text":"9️⃣ 병렬 프로그래밍과 동시성 프로그래밍은 각각 무엇인가요? 서로 반대되는 개념일까요?","type":"text"}]}]},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"동시성","type":"text"}]},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"논리적인 개념","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"메인 스레드가 아닌 다른 소프트웨어적인 스레드에서 동시에 일을하는 개념"}]}]}],"type":"unorderedList"}]},{"content":[{"inlineContent":[{"type":"text","text":"병렬"}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"물리적인 개념"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"물리적 스레드에서 실제 동시에 일을 하는 개념"}],"type":"paragraph"}]}]}]}],"type":"unorderedList"},{"type":"thematicBreak"},{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"[DispatchQueue의 초기화]"}]}]},{"type":"codeListing","code":["convenience init(label: String,","                 qos: DispatchQoS = .unspecified,","                 attributes: DispatchQueue.Attributes = [],","                 autoreleaseFrequency: DispatchQueue.AutoreleaseFrequency = .inherit,","                 target: DispatchQueue? = nil)"],"syntax":"swift"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"Label","type":"text"}]},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"DispatchQueue의 label을 설정해주는 파라미터다."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"디버깅 환경에서 추적하기 위해 작성하는 String 값이다. 식별자와 같다."}]}]}],"type":"unorderedList"}]},{"content":[{"inlineContent":[{"text":"qos","type":"text"}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"DispatchQoS 타입의 값을 받는 파라미터"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"QoS란?"}]},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Quality of Service의 약자로 실행될 Task들의 우선순위를 정해주는 값이다."}]}]}],"type":"unorderedList"}]}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Attributes","type":"text"}]},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"text","text":"DispatchQueue의 속성을 정해주는 값"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":".concurrent로 초기화 한다면 다중 스레드 환경에서 코드를 처리하는 DispatchQueue가 된다.","type":"text"}]}]},{"content":[{"inlineContent":[{"text":"기본값으로 아무 설정도 하지 않는 다면 Serial DispatchQueue가 만들어진다.","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":".initiallyInactive 속성은 작업을 큐에 담아 놓기만 하고 active()를 호출하기 전까지는 작업을 처리하지 않는 속성이다.","type":"text"}],"type":"paragraph"}]}]}]}],"type":"unorderedList"},{"syntax":"swift","type":"codeListing","code":["import Foundation","","let yellow = DispatchWorkItem {","    for _ in 1...5 {","        print(\"😀😀😀😀😀\")","        sleep(1)","    }","}","","let myDispatch = DispatchQueue(label: \"Odong\", attributes: .initiallyInactive)","","myDispatch.async(execute: yellow) \/\/ 코드 블록 호출 안됨.","myDispatch.activate()"]},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"text":"autoreleaseFrequency","type":"text"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"DispatchQueue가 자동으로 객체를 해제하는 빈도의 값을 결정하는 파라미터"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"즉 객체를 autorelease 해주는 빈도이며 기본값은 inherit이다."}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"inherit: target과 같은 빈도를 가진다."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"workItem: workItem이 실행될 때 마다 객체들을 해제한다."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Never: autorelease를 하지 않는다.","type":"text"}]}]}]}]}],"type":"unorderedList"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Target"}]},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"코드 블럭을 실행할 큐를 target으로 설정할 수 있다."}]}]}],"type":"unorderedList"}]}]},{"type":"paragraph","inlineContent":[{"inlineContent":[{"text":"[QoS]","type":"text"}],"type":"strong"}]},{"items":[{"content":[{"inlineContent":[{"type":"text","text":"여기서 말하는 우선 순위는 무엇에 더 많은 에너지를 쏟을까? 와 같은 맥락이다."}],"type":"paragraph"},{"items":[{"content":[{"inlineContent":[{"text":"더 많은 에너지를 쏟는다는 것은 더 많은 스레드를 할당한다는 이야기다.","type":"text"}],"type":"paragraph"}]}],"type":"unorderedList"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"우선순위 종류"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"User-interactive"}]},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"text","text":"Main 스레드에서 작업하며 사용자 인터페이스, 새로고침, 애니메이션 등 사용자와 상호 작용하는 작업에 할당한다."}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"작업이 빠르게 수행되지 않으면 유저 인터페이스는 멈추게 도니다. 반응성(responsiveness)과 성능(performance)에 중점을 둔다.","type":"text"}]}]}]}]},{"content":[{"inlineContent":[{"text":"User-initiated","type":"text"}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"문서를 열거나 버튼을 클릭해 액션을 수행하는 것처럼 빠른 결과를 요구하는 유저와의 상호작용 작업에 할당한다.","type":"text"}]}]},{"content":[{"inlineContent":[{"text":"몇 초 이내의 짧은 시간 내에 수행해야하는 작업으로 반응성과 성능에 중점을 둔다.","type":"text"}],"type":"paragraph"}]}]}]},{"content":[{"inlineContent":[{"type":"text","text":"Default"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"QoS를 할당해주지 않을 경우 기본값으로 사용되며 User initiate와 Utility의 중간 수준의 레벨"}]}]}],"type":"unorderedList"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Utility"}]},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"데이터를 읽거나 다운로드하는 작업처럼 작업이 완료되는 데에 어느정도 시간이 걸리거나 즉각적인 결과가 요구되지 않는 작업에 할당한다.","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"반응성, 성능, 에너지 효율의 밸런스에 중점을 둔다."}]}]}],"type":"unorderedList"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Background","type":"text"}]},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"text","text":"index 생성, 동기화, 백업 등 사용자가 볼 수 없는 백그라운드의 작업에 할당한다."}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"에너지 효율에 중점을 둔다","type":"text"}],"type":"paragraph"}]}]}]},{"content":[{"inlineContent":[{"type":"text","text":"Unspecified"}],"type":"paragraph"},{"items":[{"content":[{"inlineContent":[{"type":"text","text":"QoS의 정보가 없음을 나타내며 시스템이 QoS를 추론해야 한다."}],"type":"paragraph"}]}],"type":"unorderedList"}]}]}]}],"type":"unorderedList"},{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"text":"[Async의 파라미터에 대해서]","type":"text"}]}]},{"syntax":"swift","code":["func async(group: DispatchGroup? = nil, qos: DispatchQoS = .unspecified, flags: DispatchWorkItemFlags = [], execute work: @escaping () -> Void)"],"type":"codeListing"},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"text":"Group","type":"text"}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"DispatchQueue의 async 코드 블럭을 묶어서 관리해주는 DispatchGroup이다.","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"여러 스레드에서 비동기로 작업을 처리하다보면 여러개의 작업을 함께 관리해주어야할 때가 있다."}]}]}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"QoS"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"앞서 설명했던 DispatchQueue와 같은 내용이다."}]}]},{"content":[{"inlineContent":[{"text":"역시 적절한 케이스를 설정해주면 시스템이 알아서 관리해준다.","type":"text"}],"type":"paragraph"}]}]}]},{"content":[{"inlineContent":[{"text":"Flags","type":"text"}],"type":"paragraph"},{"items":[{"content":[{"inlineContent":[{"text":"DispatchWorkItemFlags 타입의 값을 받는 파라미터","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"코드 블럭을 실행할 때 추가 속성을 결정한다."}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"기본값은 아무 속성도 부여하지 않는다."}]}]},{"content":[{"inlineContent":[{"type":"text","text":"여러가지 속성을 한번에 부여할 수도 있다."}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"assingCureentContext"}]},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"text","text":"코드 블럭을 실행하는 Context(queue 혹은 스레드)의 속성을 상속받았다. QoS와 같은 속성을 동일하게 한다는 이야기다."}],"type":"paragraph"}]}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"barrier","type":"text"}]},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"text":"Concurrent queue 환경에서 barrier(장벽, 차단) 역할을 한다. barrier 속성의 코드 블럭이 실행되기 전에 실행되었던 코드들은 완료까지 실행되고 barrier 속성의 코드블럭이 실행되기 전까지 다른 코드 블럭은 실행되지 않는다.","type":"text"}],"type":"paragraph"}]}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"detached"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"실행할 코드 블럭에 실행중인 context(queue 혹은 스레드)의 속성을 적용하지 않는다."}]}]}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"enforceQoS","type":"text"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"실행중인 context의 QoS보다 실행할 코드 블럭의 QoS에 더 높은 우선 순위를 부여한다."}]}]}]}]},{"content":[{"inlineContent":[{"type":"text","text":"inheritQoS"}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"enforceQoS와 반대로 실행중인 context의 QoS에 더 높은 우선 순위를 부여한다."}]}]}]}]},{"content":[{"inlineContent":[{"type":"text","text":"noQoS"}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"QoS를 할당하지 않고 코드 블럭을 실행시킨다.","type":"text"}]}]},{"content":[{"inlineContent":[{"text":"assingCureentContext보다 우선시 되는 속성이다.","type":"text"}],"type":"paragraph"}]}]}]}]}]}],"type":"unorderedList"}]}]},{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"text":"[completionHandler]","type":"text"}]}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"이미 구현되어있는 코드들 중에 completionHandler이나 completion 이라는 클로저를 가진 메소드들은 함수의 실행 순서를 보장받을 수 있는 클로저다.","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"특히 escaping 클로저는 함수의 실행이 끝나면 함수의 밖에서 실행되는 작업들이다.","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"completionHandler와 같은 클로저를 사용하는 경우에는 비동기 메서드일 때에도 작업이 종료되는 시점을 추적할 수 있고 순서를 보장받을 수 있다."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"대표적인 예로 URLSession이 있다."}]},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"서버와의 통신을 도와주는 API"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"서버에서 데이터를 받아오는 메소드를 비동기로 실행시킨다."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"하지만 비동기로 작업이 처리되는 경우 그 작업이 언제 끝날지를 정확하게 파악할 수 없다."}]}]},{"content":[{"inlineContent":[{"type":"text","text":"스레드는 시스템이 관리해주기 때문이다."}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"때문에 completionHandler 혹은 completion와 같은 클로저를 구현해준다면 작업이 끝나는 시점에 원하는 동작을 수행시켜줄 수 있는 것이다.","type":"text"}]}]}],"type":"unorderedList"}]}]},{"type":"paragraph","inlineContent":[{"inlineContent":[{"text":"[DispatchGroup]","type":"text"}],"type":"strong"}]},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"text","text":"비동기적으로 처리되는 작업들을 그룹으로 묶어 그룹 단위로 작업 상태를 추적할 수 있는 기능이다."}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"즉 사용하면 async들을 묶어서 그룹의 작업이 끝나는 시점을 추적하여 어떠한 동작을 수행시킬 수가 있다."}]}]},{"content":[{"inlineContent":[{"type":"text","text":"이 때 묶어줄 async 작업들이 꼭 같은 큐, 스레드에 있지 않더라도 묶어줄 수 있다."}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"DispatchGroup은 async에서만 사용할 수 있다.","type":"text"}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"text","text":"비동기로 처리되는 작업은 작업이 끝나는 시점을 정확하게 예측하기 어렵기 때문이다."}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"동기의 경우 작업 종료 시점을 따로 추적할 필요가 없다. 작업이 처리되기를 반드시 기다렸다가 다음 작업을 수행하기 때문이다."}],"type":"paragraph"}]}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"사용하는 방법"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"aysnc를 호출하면서 파라미터로 group을 지정해준다.","type":"text"}]}]},{"content":[{"inlineContent":[{"text":"Enter, leave를 코드의 앞뒤로 호출하여 group을 지정해준다.","type":"text"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"enter와 leave는 DispatchGroup이 enter()부터 leave()까지 포함된다라는 의미"}]}]}],"type":"unorderedList"}]}]}]}]},{"type":"codeListing","code":["let group = DispatchGroup()","","\/\/ enter, leave를 사용하지 않는 경우","DispatchQueue.main.async(group: group) {}","DispatchQueue.global().async(group: group) {}","","\/\/ enter, leave를 사용하는 경우","group.enter()","DispatchQueue.main.async {}","DispatchQueue.global().async {}","group.leave()"],"syntax":"swift"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"이렇게 묶어낸 그룹에 대해 notify() 혹은 wait()으로 작업을 추적해줄 수 있다.","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"notify"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"DispatchGroup의 업무가 끝나는 시점에 원하는 동작을 수행하기 위한 메소드다.","type":"text"}]}]}]}]}]},{"code":["import Foundation","","let red = DispatchWorkItem {","    for _ in 1...5 {","        print(\"🥵🥵🥵🥵🥵\")","        sleep(1)","    }","}","","let yellow = DispatchWorkItem {","    for _ in 1...5 {","        print(\"😀😀😀😀😀\")","        sleep(1)","    }","}","","let blue = DispatchWorkItem {","    for _ in 1...5 {","        print(\"🥶🥶🥶🥶🥶\")","        sleep(2)","    }","}","","let group = DispatchGroup()","","DispatchQueue.global().async(group: group, execute: blue)","DispatchQueue.global().async(group: group, execute: red)","","\/\/ group.enter()","\/\/ DispatchQueue.global().async(execute: blue)","\/\/ DispatchQueue.global().async(execute: red)","\/\/ group.leave()","","group.notify(queue: .main) {","    print(\"모든 작업이 끝났습니다.\")","}"],"type":"codeListing","syntax":"swift"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"위 코드가 실행되면 notify 메서드에 의해 group의 모든 작업이 끝나기를 기다렸다가 코드블럭을 실행시켜준다."}]}]},{"content":[{"inlineContent":[{"type":"text","text":"이때 notify의 파라미터 queue는 코드블럭을 실행시킬 queue를 말한다."}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Wait","type":"text"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"DispatchGroup의 수행이 끝나기를 기다리기만 하는 메서드다."}]}]},{"content":[{"inlineContent":[{"type":"text","text":"notify와 달리 별도의 코드블럭을 실행하지 않는다."}],"type":"paragraph"}]}]}]}],"type":"unorderedList"},{"code":["let group = DispatchGroup()","","DispatchQueue.global().async(group: group, execute: blue)","DispatchQueue.global().async(group: group, execute: red)","","group.wait()","print(\"모든 작업이 끝났습니다.\")","","\/\/ group.wait(timeout: 10)","\/\/ print(\"모든 작업이 끝났습니다.\")"],"type":"codeListing","syntax":"swift"},{"items":[{"content":[{"inlineContent":[{"type":"text","text":"Wait 메서드에는 timeout 파라미터를 설정해줄 수 있다."}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"만약 10을 전달하면 group을 딱 10초 동안만 기다리는 것이다.","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"만약 10초가 넘어갔는데도 group의 작업이 끝나지 않는다면 더이상 기다리지 않고 다음 코드를 실행한다."}],"type":"paragraph"}]}],"type":"unorderedList"},{"type":"paragraph","inlineContent":[{"inlineContent":[{"type":"text","text":"[Race Condition]"}],"type":"strong"}]},{"type":"codeListing","syntax":"swift","code":["import Foundation","","var cards = [1, 2, 3, 4, 5, 6, 7, 8, 9]","","DispatchQueue.global().async {","    for _ in 1...3 {","        let card = cards.removeFirst()","        print(\"야곰: \\(card) 카드를 뽑았습니다!\")","    }","}","","DispatchQueue.global().async {","    for _ in 1...3 {","        let card = cards.removeFirst()","        print(\"노루: \\(card) 카드를 뽑았습니다!\")","    }","}","","DispatchQueue.global().async {","    for _ in 1...3 {","        let card = cards.removeFirst()","        print(\"오동나무: \\(card) 카드를 뽑았습니다!\")","    }","}","","\/* 출력","야곰: 1 카드를 뽑았습니다!","노루: 1 카드를 뽑았습니다!","오동나무: 1 카드를 뽑았습니다!","야곰: 2 카드를 뽑았습니다!","노루: 5 카드를 뽑았습니다!","야곰: 6 카드를 뽑았습니다!","노루: 8 카드를 뽑았습니다!","오동나무: 7 카드를 뽑았습니다!","오동나무: 9 카드를 뽑았습니다!","*\/"]},{"items":[{"content":[{"inlineContent":[{"type":"text","text":"코드가 동작은 하지만 제대로 동작하고 있지는 않다."}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"이런 문제가 발생한 이유는 하나의 배열에 여러 스레드가 동시에 접근해서다."}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"스레드가 여러개인 상황에서는 코드가 동시에 실행되어 하나의 값에 동시에 접근하는 경우가 발생할 수 있는데 이러한 경우는 Race Condition이라고 한다."}]}]}],"type":"unorderedList"},{"inlineContent":[{"inlineContent":[{"type":"text","text":"[Thread Safe]"}],"type":"strong"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Race Condition이 발생하는 이유는 Swift의 배열이 Thread Safe하지 않기 때문이다."}]}]},{"content":[{"inlineContent":[{"type":"text","text":"Thread Safe하다는 것은 여러 스레드에서 동시에 접근이 불가능한 것을 말한다."}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"이러한 문제들을 해결해보려면 어떻게 해야할까?"}]},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"DispatchSemaphore를 활용하여 접근할 수 있는 스레드의 수를 제어해주거나","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Serial Queue를 활용한다."}]},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"Race Condition이 발생하는 이유는 여러 스레드에서 질서없이 배열에 접근했기 때문이다.","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"그러므로 Serial Queue로 질서를 만들어 주면 문제를 해결할 수 있게 된다."}],"type":"paragraph"}]}],"type":"unorderedList"}]}],"type":"unorderedList"}]}],"type":"unorderedList"},{"type":"codeListing","syntax":"swift","code":["import Foundation","","var cards = [1, 2, 3, 4, 5, 6, 7, 8, 9]","let pickCardsSerialQueue = DispatchQueue(label: \"PickCardsQueue\")","","DispatchQueue.global().async {","    for _ in 1...3 {","        pickCardsSerialQueue.sync {","            let card = cards.removeFirst()","            print(\"야곰: \\(card) 카드를 뽑았습니다!\")","        }","    }","}","","DispatchQueue.global().async {","    for _ in 1...3 {","        pickCardsSerialQueue.sync {","            let card = cards.removeFirst()","            print(\"노루: \\(card) 카드를 뽑았습니다!\")","        }","    }","}","","DispatchQueue.global().async {","    for _ in 1...3 {","        pickCardsSerialQueue.sync {","            let card = cards.removeFirst()","            print(\"오동나무: \\(card) 카드를 뽑았습니다!\")","        }","    }","}"]},{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"[DispatchSemaphore]"}]}]},{"code":["class DispatchSemaphore : DispatchObject"],"type":"codeListing","syntax":"swift"},{"items":[{"content":[{"inlineContent":[{"type":"text","text":"공유 자원에 접근할 수 있는 스레드의 수를 제어해주는 역할을 한다."}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"몇개의 스레드에 접근을 허용할 것인지 제어할 수 있기 때문에 접근을 1개의 스레드만 허용한다면 Race Condition을 방지할 수 있다."}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"DispatchSemaphore는 semaphore count를 카운트하는 식으로 동작한다."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"예시로 하나의 스레드가 접근을 하면 count에 -1을, 접근이 끝나면 count에 +1을 해준다."}]}]}],"type":"unorderedList"},{"syntax":"swift","code":["let semaphore = DispatchSemaphore(value: 1) \/\/ count = 1","","DispatchQueue.global().async {","    semaphore.wait() \/\/ count -= 1","","    semaphore.signal() \/\/ count += 1","}"],"type":"codeListing"},{"items":[{"content":[{"inlineContent":[{"type":"text","text":"wait()은 값에 접근했다고 알리는 메소드, signal()은 볼 일 다봤다는 메소드"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"주의사항은 반드시 두 메소드를 짝지어서 호출해주어야 한다."}]}]}],"type":"unorderedList"},{"type":"paragraph","inlineContent":[{"inlineContent":[{"type":"text","text":"[UI 작업이 왜 Main Thread에서만 가능할까?]"}],"type":"strong"}]},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"UIKit은 Thread Safe하지 않다."}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"UIKit의 UI요소들이 여러 스레드에서 접근가능하게 되면 어떤일이 발생할까?"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"앞서 배웠던 것처럼 Racd Condition이 발생하게 된다.","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"버튼의 모양을 바꾸는 일, 버튼의 위치를 이동시키는 일, 버튼의 색을 바꾸는 일 등이 충돌할 수 있다.","type":"text"}]}]},{"content":[{"inlineContent":[{"text":"그러므로 UIKit 작업dms Serial Queue인 Main Thread로 가져와서 작업해야한다.","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Thread Safe하게 만들지 않은 이유는 사실 성능 측면에서 Thread Safe한 것이 효율적이지 않기 때문이다."}]}]}]}]},{"content":[{"inlineContent":[{"type":"text","text":"다른 직렬큐에 넣으면 안될까?"}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"text","text":"UI 작업을 꼭 메인 스레드에서 작업해야하는 이유는 메인 스레드에는 Main RunLoop가 동작하고 있기 때문이다."}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"메인 스레드에서는 RunLoop가 일정한 주기를 유지하며 계속 동작하고 있다."}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"이 주기에 맞추어서 사용자의 입력을 받아서 UI를 그리게 된다.","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"이러한 주기를 View Drawing Cycle이라고 한다."}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"따라서 모든 스레드의 RunLoop에 따라 각자가 UI를 그리게 된다면 UI가 그려지는 시점이 모두 제각각이 되기 때문이다."}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"그렇게 되면 비효율적일 뿐더러 Race Condition이 발생하게 된다.","type":"text"}]}]}]}]}],"type":"unorderedList"},{"type":"heading","anchor":"%EB%8A%90%EB%82%80-%EC%A0%90","level":2,"text":"느낀 점"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"어제부터 오늘까지 GCD 관련 강의를 3가지를 보았는데, 점점 이해가 채워지는 기분이 든다.","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"앨런 강의 살까…."}]}]}]},{"type":"thematicBreak"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"참고링크","type":"text"}]},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"text":"https:\/\/www.youtube.com\/watch?v=EL5n2U8XNpQ&list=PLqK3bFbiW77MBn0ofPRjGDBU9Ytnz9-6S","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"https:\/\/yagom.net\/courses\/%eb%8f%99%ec%8b%9c%ec%84%b1-%ed%94%84%eb%a1%9c%ea%b7%b8%eb%9e%98%eb%b0%8d-concurrency-programming\/"}],"type":"paragraph"}]}]}]}]}]}],"schemaVersion":{"major":0,"minor":3,"patch":0},"sections":[],"variants":[{"paths":["\/documentation\/arinote\/211217_gcd"],"traits":[{"interfaceLanguage":"swift"}]}],"metadata":{"role":"article","roleHeading":"Article","modules":[{"name":"Ari's Notes"}],"title":"211217 GCD"},"hierarchy":{"paths":[["doc:\/\/AriNote\/documentation\/AriNote","doc:\/\/AriNote\/documentation\/AriNote\/CS"]]},"identifier":{"url":"doc:\/\/AriNote\/documentation\/AriNote\/211217_GCD","interfaceLanguage":"swift"},"references":{"https://i.imgur.com/cGBjDZU.png":{"identifier":"https:\/\/i.imgur.com\/cGBjDZU.png","type":"image","alt":null,"variants":[{"traits":["1x","light"],"url":"https:\/\/i.imgur.com\/cGBjDZU.png"}]},"https://i.imgur.com/4LCoi3i.png":{"variants":[{"traits":["1x","light"],"url":"https:\/\/i.imgur.com\/4LCoi3i.png"}],"identifier":"https:\/\/i.imgur.com\/4LCoi3i.png","alt":null,"type":"image"},"https://i.imgur.com/Ufmi1jn.png":{"identifier":"https:\/\/i.imgur.com\/Ufmi1jn.png","type":"image","alt":null,"variants":[{"traits":["1x","light"],"url":"https:\/\/i.imgur.com\/Ufmi1jn.png"}]},"doc://AriNote/documentation/AriNote":{"kind":"symbol","type":"topic","identifier":"doc:\/\/AriNote\/documentation\/AriNote","abstract":[{"type":"codeVoice","code":"Today I Learned"}],"url":"\/documentation\/arinote","title":"Ari's Notes","role":"collection"},"https://i.imgur.com/670zQzv.png":{"variants":[{"traits":["1x","light"],"url":"https:\/\/i.imgur.com\/670zQzv.png"}],"identifier":"https:\/\/i.imgur.com\/670zQzv.png","alt":null,"type":"image"},"https://i.imgur.com/90ykKbI.png":{"identifier":"https:\/\/i.imgur.com\/90ykKbI.png","type":"image","alt":null,"variants":[{"traits":["1x","light"],"url":"https:\/\/i.imgur.com\/90ykKbI.png"}]},"https://i.imgur.com/rJa10vZ.png":{"variants":[{"traits":["1x","light"],"url":"https:\/\/i.imgur.com\/rJa10vZ.png"}],"identifier":"https:\/\/i.imgur.com\/rJa10vZ.png","alt":null,"type":"image"},"https://i.imgur.com/XQiK8YH.png":{"identifier":"https:\/\/i.imgur.com\/XQiK8YH.png","type":"image","alt":null,"variants":[{"traits":["1x","light"],"url":"https:\/\/i.imgur.com\/XQiK8YH.png"}]},"https://i.imgur.com/hGbb0Zv.png":{"variants":[{"traits":["1x","light"],"url":"https:\/\/i.imgur.com\/hGbb0Zv.png"}],"identifier":"https:\/\/i.imgur.com\/hGbb0Zv.png","alt":null,"type":"image"},"https://i.imgur.com/vhjSsha.png":{"identifier":"https:\/\/i.imgur.com\/vhjSsha.png","type":"image","alt":null,"variants":[{"traits":["1x","light"],"url":"https:\/\/i.imgur.com\/vhjSsha.png"}]},"https://i.imgur.com/S8LqcTq.png":{"variants":[{"traits":["1x","light"],"url":"https:\/\/i.imgur.com\/S8LqcTq.png"}],"identifier":"https:\/\/i.imgur.com\/S8LqcTq.png","alt":null,"type":"image"},"doc://AriNote/documentation/AriNote/CS":{"type":"topic","role":"collectionGroup","url":"\/documentation\/arinote\/cs","kind":"article","title":"CS","identifier":"doc:\/\/AriNote\/documentation\/AriNote\/CS","abstract":[{"type":"text","text":"Computer Science"}]},"https://i.imgur.com/ZyqjbsI.png":{"identifier":"https:\/\/i.imgur.com\/ZyqjbsI.png","type":"image","alt":null,"variants":[{"traits":["1x","light"],"url":"https:\/\/i.imgur.com\/ZyqjbsI.png"}]},"https://i.imgur.com/CSuoGv7.png":{"variants":[{"traits":["1x","light"],"url":"https:\/\/i.imgur.com\/CSuoGv7.png"}],"identifier":"https:\/\/i.imgur.com\/CSuoGv7.png","alt":null,"type":"image"}}}