{"variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/documentation\/arinote\/211224_escapingclosure,_autoclosure,_weak,_wildcard,_naming"]}],"identifier":{"url":"doc:\/\/AriNote\/documentation\/AriNote\/211224_escapingClosure,_autoClosure,_weak,_wildcard,_naming","interfaceLanguage":"swift"},"metadata":{"title":"211224 escapingClosure, autoClosure, weak, wildcard, naming","modules":[{"name":"Ari's Notes"}],"roleHeading":"Article","role":"article"},"hierarchy":{"paths":[["doc:\/\/AriNote\/documentation\/AriNote","doc:\/\/AriNote\/documentation\/AriNote\/Swift"]]},"primaryContentSections":[{"kind":"content","content":[{"text":"TIL (Today I Learned)","level":1,"type":"heading","anchor":"TIL-Today-I-Learned"},{"inlineContent":[{"type":"text","text":"12월 24일 (금)"}],"type":"paragraph"},{"text":"학습 내용","anchor":"%ED%95%99%EC%8A%B5-%EB%82%B4%EC%9A%A9","level":2,"type":"heading"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"은행창구매니저 STEP 2 진행","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Escaping Closure"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Auto Closure","type":"text"}]}]}]},{"type":"paragraph","inlineContent":[{"type":"text","text":" "}]},{"level":2,"anchor":"%EA%B3%A0%EB%AF%BC%ED%95%9C-%EC%A0%90--%ED%95%B4%EA%B2%B0-%EB%B0%A9%EB%B2%95","text":"고민한 점 \/ 해결 방법","type":"heading"},{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"[Delegate 패턴 구현 시 네이밍]"}]}]},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"text":"허황이 공유해주었는데, 구글의 ","type":"text"},{"identifier":"https:\/\/google.github.io\/swift\/#delegate-methods","isActive":true,"type":"reference"},{"type":"text","text":"를 참고하였다고 한다."}],"type":"paragraph"}]}]},{"type":"aside","content":[{"type":"paragraph","inlineContent":[{"text":"The term “delegate’s source object” refers to the object that invokes methods on the delegate. For example, a ","type":"text"},{"type":"codeVoice","code":"UITableView"},{"text":" is the source object that invokes methods on the ","type":"text"},{"type":"codeVoice","code":"UITableViewDelegate"},{"type":"text","text":" that is set as the view’s "},{"code":"delegate","type":"codeVoice"},{"text":" property.","type":"text"}]}],"style":"note","name":"Note"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"CoCoa의 프로토콜에서 영감을 받았다고 적혀있다. ","type":"text"},{"code":"UITableViewDelegate나","type":"codeVoice"},{"type":"text","text":" "},{"code":"UINavigationControllerDelegate","type":"codeVoice"},{"type":"text","text":" 프로토콜의 메소드들의 네이밍을 확인해보면 모두 "},{"type":"codeVoice","code":"tableView"},{"type":"text","text":", "},{"type":"codeVoice","code":"navigationController"},{"text":"가 앞에 꼭 붙어서 네이밍이 되어있다.","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"따라서 대리자의 객체를 ","type":"text"},{"type":"codeVoice","code":"첫번째 argument"},{"type":"text","text":"로 사용하여 네이밍을 한다고 적혀있다."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"네이밍은 역시 기본 프레임워크를 참고하면 되는 것인가…? 😂","type":"text"}]}]}]},{"type":"thematicBreak"},{"inlineContent":[{"inlineContent":[{"type":"text","text":"[와일드카드 패턴으로 생성한 인스턴스의 참조 카운트]"}],"type":"strong"}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"code":"상황","type":"codeVoice"},{"text":" 기존에 와일드카드 패턴으로 인스턴스 생성한 타입이 Delegate를 채택하고 있던 형태였다. 이후 순환참조 문제가 우려되어 각 타입들마다 delegate 프로퍼티에 weak 키워드를 붙여주었다.","type":"text"}]},{"code":["final class Bank {","    private let bankClerk: BankClerk","    private var customerQueue = Queue<Customer>()","    weak var delegate: BankDelegate?","...","}","","\/\/ main ...","func run() {","    let bankClerk = BankClerk()","    let bank = Bank(bankClerk: bankClerk)","    let bankManager = BankManager(bank: bank)","    let _ = BankClerkViewController(bankClerk: bankClerk)","    let _ = BankViewController(bank: bank) \/\/ ","...","}"],"syntax":"swift","type":"codeListing"}]},{"content":[{"inlineContent":[{"code":"이유","type":"codeVoice"},{"type":"text","text":" 그런데 weak키워드를 붙여주니 해당 타입에서 출력해주었던 메소드가 실행되지 않았다. init과 deinit을 통해 디버깅을 해보니 와일드카드 패턴으로 생성한 인스턴스가 생성과 동시에 해제되는 것을 확인할 수 있었다. "},{"type":"codeVoice","code":"와일드카드 패턴"},{"type":"text","text":"은 값을 해체하거나 무시하는 패턴중 하나이므로 "},{"type":"codeVoice","code":"weak 키워드"},{"text":"가 추가됨과 동시에 retain count가 올라가지 않기 때문에 생성과 동시에 해제되는 것이였다.","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"code":"해결","type":"codeVoice"},{"type":"text","text":" 사용하지 않는 viewController(은행원, 은행)를 상수에 담으면 xcode에서 경고 메세지가 출력된다. 와일드 카드 패턴을 사용해서 순환참조 문제를 해결할 수 있다고 판단되어 weak 키워드를 제거하고 와일드카드 패턴을 사용하기로 결정했다."}]},{"type":"codeListing","syntax":"swift","code":["final class Bank {","    private let bankClerk: BankClerk","    private var customerQueue = Queue<Customer>()","    var delegate: BankDelegate?","...","}","","func run() {","    let bankClerk = BankClerk()","    let bank = Bank(bankClerk: bankClerk)","    let bankManager = BankManager(bank: bank)","    let _ = BankClerkViewController(bankClerk: bankClerk)","    let _ = BankViewController(bank: bank) ","...","}"]}]}]},{"type":"thematicBreak"},{"inlineContent":[{"type":"strong","inlineContent":[{"text":"[Escaping Closure]","type":"text"}]}],"type":"paragraph"},{"code":["class ViewModel {","    var completionhandler: (() -> Void)? = nil","    ","    func fetchData(completion: @escaping () -> Void) {","        completionhandler = completion","    }","}"],"type":"codeListing","syntax":"swift"},{"items":[{"content":[{"inlineContent":[{"text":"Escaping 클로저란?","type":"text"}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"text","text":"함수 밖(Escaping)에서 실행되는 클로저"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"즉 함수 안에서 정의된 클로저가 외부 변수들에 대한 접근을 허용할 때 사용한다.","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"사용되는 흔한 예로는 비동기로 실행되는 HTTP Request CompletionHandler가 있다."}],"type":"paragraph"}]}]}]}],"type":"unorderedList"},{"type":"codeListing","code":["func makeRequest(_ completion: @escaping (Result<(Data, URLResponse), Error>) -> Void) {","  URLSession.shared.dataTask(with: URL(string: \"http:\/\/jusung.github.io\/\")!) { data, response, error in","    if let error = error {","      completion(.failure(error))","    } else if let data = data, let response = response {","      completion(.success((data, response)))","    }","  }","}"],"syntax":"swift"},{"content":[{"inlineContent":[{"code":"makeRequest()","type":"codeVoice"},{"text":" 함수에서 사용되는 ","type":"text"},{"type":"codeVoice","code":"completion"},{"type":"text","text":" 클로저는 함수 실행 중에 즉시 실행되지 않고 URL 요청이 끝난 후 비동기로 실행된다."},{"text":" ","type":"text"},{"type":"text","text":"이 경우에도 "},{"code":"completion","type":"codeVoice"},{"text":"의 타입에 ","type":"text"},{"code":"@escaping","type":"codeVoice"},{"type":"text","text":"을 붙여서 escaping 클로저라는 것을 명시해줘야 한다."},{"type":"text","text":" "},{"type":"text","text":"보통 클로저가 다른 변수에 저장되어 나중에 실행되거나 비동기로 실행될 때 escaping 클로저가 사용된다."}],"type":"paragraph"}],"style":"note","name":"Note","type":"aside"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"기본적으로 @escaping 키워드를 따로 명시하지 않는다면 매개변수로 사용되는 클로저는 기본으로 비탈출 클로저이다.","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"클로저가 함수를 탈출할 수 있는 경우"}]}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"함수 외부에 정의된 변수나 상수에 저장되어 함수가 종료된 후 사용할 경우"}]},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"text":"예를 들어 비동기로 작업을 하기 위해서 컴플리션 핸들러를 전달인자를 이용해 클로저 형태로 받는 함수","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"함수가 작업을 종료하고 난 이후 (즉, 함수의 return 후)에 컴플리션 핸들러, 즉 클로저를 호출하기 때문에 클로저는 함수를 탈출해 있어야만 한다.","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"함수의 전달일자로 전달받은 클로저를 다시 반환할 때도 마찬가지이다."}],"type":"paragraph"}]}]}]}]}]},{"content":[{"inlineContent":[{"inlineContent":[{"type":"text","text":"escaping 클로저임을 명시한 경우"}],"type":"strong"}],"type":"paragraph"},{"items":[{"content":[{"inlineContent":[{"text":"클로저 내부에서 해당 타입의 프로퍼티나, 메소드, 서브스크립트 등에 접근하려면 self 키워드를 명시적으로 사용해야 한다.","type":"text"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"escaping 클로저를 사용할 때는 접근할 수 있는 경우의 수가 많기 때문에 어디에 접근하는 것인지 명확하게 해줘야 한다는 것이다.","type":"text"}]}]}],"type":"unorderedList"}]},{"content":[{"inlineContent":[{"type":"text","text":"비탈출 클로저는 self 키워드를 꼭 써주지 않아도 된다."}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"class와 같은 참조 타입이 아닌 Struct, enum과 같은 값타입에서는 mutating reference의 캡쳐를 허용하지 않기 때문에 self 사용이 불가능 하다.","type":"text"}],"type":"paragraph"}]}],"type":"unorderedList"}]}]},{"type":"thematicBreak"},{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"text":"[Auto Closure]","type":"text"}]}]},{"items":[{"content":[{"inlineContent":[{"type":"text","text":"함수의 전달인자로 전달하는 표현을 자동으로 변환해주는 클로저"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"자동 클로저는 전달인자를 갖지 않는다."}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"호출되었을 때 자신이 감싸고 있는 코드의 결괏값을 반호나한다."}]}]},{"content":[{"inlineContent":[{"type":"text","text":"Swift에는 "},{"code":"함수 타입","type":"codeVoice"},{"text":" 이라는 것이 있다.","type":"text"}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"즉 어떤 상수나 변수에 함수를 저장해둘 수 있다는 말이다."}]}]}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"자동클로저는 클로저가 호출되기 전까지 클로저 내부의 코드가 동작하지 않는다. 따라서 연산을 지연시킬 수 있다."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"이 과정은 연산에 자원을 많이 소모한다거나 부작용이 우려될 때 유용하게 사용할 수 있다."}]},{"items":[{"content":[{"inlineContent":[{"type":"text","text":"왜냐하면 코드의 실행을 제어하기 좋기 때문이다."}],"type":"paragraph"}]}],"type":"unorderedList"}]}],"type":"unorderedList"},{"type":"codeListing","code":["var customersInLine: [String] = [\"ari\", \"yong\", \"han\", \"hami\"]","","\/\/ 클로저를 만들어두면 클로저 내부의 코드를 미리 실행하지 않고 가지고만 있는다.","let customerProvider: () -> String = {","    return customersInLine.removeFirst()","}","","func serveCustomer(_ customerProvider: @autoclosure () -> String) {","    print(customerProvider())","}","","serveCustomer(customerProvider()) \/\/ ari"],"syntax":"swift"},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"text","text":"String 값을 반환하는 함수를 매개변수로 받는다."}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"여기서 auto closure를 사용하게 되면 함수 타입의 반환타입이 매개변수의 타입이 된다."}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"String 타입의 값을 전달받는 이유는 자동 클로저의 반환타입이 String이기 때문이다.","type":"text"}]}]}]}]},{"content":[{"inlineContent":[{"type":"text","text":"자동 클로저는 전달인자를 갖지 않기 때문에 반환타입의 값이 자동클로저의 매개변수로 전달되면 이를 클로저로 바꿔줄 수 있는 것이다."}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"따라서 자동클로저를 사용하면 기존의 사용방법처럼 클로저를 전달인자로 넘겨줄 수 없다.","type":"text"}]}]}]},{"type":"thematicBreak"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"참고링크","type":"text"}]},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"text","text":"https:\/\/icksw.tistory.com\/157"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"https:\/\/jusung.github.io\/Escaping-Closure\/","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"스위프트 프로그래밍(3판) 264p"}]}]}]}]}]}]}],"schemaVersion":{"patch":0,"minor":3,"major":0},"kind":"article","sections":[],"references":{"doc://AriNote/documentation/AriNote":{"kind":"symbol","type":"topic","identifier":"doc:\/\/AriNote\/documentation\/AriNote","abstract":[{"type":"codeVoice","code":"Today I Learned"}],"url":"\/documentation\/arinote","title":"Ari's Notes","role":"collection"},"doc://AriNote/documentation/AriNote/Swift":{"identifier":"doc:\/\/AriNote\/documentation\/AriNote\/Swift","role":"collectionGroup","abstract":[{"type":"text","text":"언어 공부"}],"kind":"article","title":"Swift","url":"\/documentation\/arinote\/swift","type":"topic"},"https://google.github.io/swift/#delegate-methods":{"identifier":"https:\/\/google.github.io\/swift\/#delegate-methods","titleInlineContent":[{"type":"text","text":"Swift Style Guide"}],"url":"https:\/\/google.github.io\/swift\/#delegate-methods","type":"link","title":"Swift Style Guide"}}}