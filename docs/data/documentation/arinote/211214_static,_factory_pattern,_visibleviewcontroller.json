{"schemaVersion":{"patch":0,"minor":3,"major":0},"variants":[{"paths":["\/documentation\/arinote\/211214_static,_factory_pattern,_visibleviewcontroller"],"traits":[{"interfaceLanguage":"swift"}]}],"sections":[],"identifier":{"url":"doc:\/\/AriNote\/documentation\/AriNote\/211214_static,_Factory_Pattern,_visibleViewController","interfaceLanguage":"swift"},"metadata":{"modules":[{"name":"Ari's Notes"}],"title":"211214 static, Factory Pattern, visibleViewController.md","role":"article","roleHeading":"Article"},"kind":"article","hierarchy":{"paths":[["doc:\/\/AriNote\/documentation\/AriNote","doc:\/\/AriNote\/documentation\/AriNote\/UIKit"]]},"primaryContentSections":[{"kind":"content","content":[{"level":1,"type":"heading","text":"TIL (Today I Learned)","anchor":"TIL-Today-I-Learned"},{"type":"paragraph","inlineContent":[{"text":"12월 14일 (화)","type":"text"}]},{"text":"학습 내용","type":"heading","level":2,"anchor":"%ED%95%99%EC%8A%B5-%EB%82%B4%EC%9A%A9"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"enum의 static","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Factory Pattern"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"topViewController와 visibleViewController"},{"type":"text","text":" "},{"type":"text","text":" "}],"type":"paragraph"}]}],"type":"unorderedList"},{"text":"고민한 점 \/ 해결 방법","anchor":"%EA%B3%A0%EB%AF%BC%ED%95%9C-%EC%A0%90--%ED%95%B4%EA%B2%B0-%EB%B0%A9%EB%B2%95","level":2,"type":"heading"},{"type":"paragraph","inlineContent":[{"inlineContent":[{"type":"text","text":"[Enum의 static 메소드, 혹은 static 변수]"}],"type":"strong"}]},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"static 같은 경우에는 메모리에 data 영역에 존재한다.","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"data영역은 프로그램이 실행하고 끝날 때 까지 데이터가 죽지않고 살아남아있다."}]}]},{"content":[{"inlineContent":[{"text":"따라서 사용여부와 상관 없이 항상 메모리가 살아있다.","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"만국박람회 프로젝트 중에 enum을 활용하여 static 메소드와 static 변수를 묶어둔 타입들이 존재하는데, 이를 어떻게 해결하면 좋을지 고민해보자"}],"type":"paragraph"}]}],"type":"unorderedList"},{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"[Factory Pattern]"}]}]},{"items":[{"content":[{"inlineContent":[{"text":"Factory Pattern이란?","type":"text"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"객체를 만들기 위한 프로토콜을 정의하지만, 어떤 클래스의 인스턴스를 생성할지에 대한 결정은 하위 클래스가 정하도록 하는 방법"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"객체 생성을 서브 클래스가 하도록 처리하는 패턴"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"즉, 객체 생성을 캡슐화할 수 있으며, 이로 인해 부모 클래스는 자식 클래스가 어떤 객체를 생성하는지 몰라도 된다."}]}]}],"type":"unorderedList"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"구조","type":"text"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Product"}]},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"Creator와 하위 클래스가 생성할 수 있는 모든 객체에 동일한 프로토콜를 선언한다","type":"text"}]}]}],"type":"unorderedList"}]},{"content":[{"inlineContent":[{"text":"Concreate Product","type":"text"}],"type":"paragraph"},{"items":[{"content":[{"inlineContent":[{"type":"text","text":"Product가 선언한 프로토콜로 만든 실제 객체다."}],"type":"paragraph"}]}],"type":"unorderedList"}]},{"content":[{"inlineContent":[{"type":"text","text":"Creator"}],"type":"paragraph"},{"items":[{"content":[{"inlineContent":[{"text":"새로운 객체를 반환하는 팩토리 메서드를 선언한다.","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"여기서 반환하는 객체는 Product 프로토콜을 준수하고 있어야 한다."}]}]}],"type":"unorderedList"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Concreate Creator"}]},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"text","text":"기본 팩토리 메소드를 override 하여 서로 다른 Product 객체를 만든다."}],"type":"paragraph"}]}]}]}]}]},{"content":[{"inlineContent":[{"type":"text","text":"언제 사용할까??"}],"type":"paragraph"},{"items":[{"content":[{"inlineContent":[{"text":"만들 객체의 클래스 종류를 예측할 수 없을 때","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"만들어야 할 객체의 하위 클래스를 명시하고 싶을 때","type":"text"}]}]}],"type":"unorderedList"}]},{"content":[{"inlineContent":[{"text":"종류","type":"text"}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"text":"Factory Method Pattern","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Abstract Factory Pattern","type":"text"}]}]}]}]}],"type":"unorderedList"},{"inlineContent":[{"type":"strong","inlineContent":[{"text":"[topViewController와 visibleViewController는 같은 VC을 가르키는 걸까?]","type":"text"}]}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"image","identifier":"https:\/\/i.imgur.com\/ghcxKC0.jpg"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"위 그림을 보면 topViewController와 visibleViewController가 맨 앞에 같은 VC을 가르키고 있다."}]}]},{"content":[{"inlineContent":[{"text":"하지만 topViewController와 visibleViewController는 반드시 같은 것은 아니다.","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"예를 들어, 하나의 VC를 모달창으로 나타낸다면 visibleViewController는 모달 VC을 가르킬 것이고, topViewController는 변하지 않는다.","type":"text"}],"type":"paragraph"}]}]},{"type":"thematicBreak"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"참고링크","type":"text"}]},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"https:\/\/theswiftdev.com\/comparing-factory-design-patterns\/","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"https:\/\/daheenallwhite.github.io\/design%20pattern\/2019\/05\/07\/Factory-Pattern\/"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"https:\/\/velog.io\/@ryan-son\/%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4-Factory-pattern-in-Swift","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"https:\/\/kingso.netlify.app\/posts\/boostcourse-view-controller\/","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"https:\/\/stackoverflow.com\/questions\/33395463\/in-uinavigationcontroller-what-is-the-difference-between-topviewcontroller-visi"}],"type":"paragraph"}]}],"type":"unorderedList"}]}]}]}],"references":{"doc://AriNote/documentation/AriNote/UIKit":{"kind":"article","title":"UIKit","abstract":[{"type":"text","text":"한몸이 되보자…"}],"type":"topic","role":"collectionGroup","identifier":"doc:\/\/AriNote\/documentation\/AriNote\/UIKit","url":"\/documentation\/arinote\/uikit"},"https://i.imgur.com/ghcxKC0.jpg":{"type":"image","identifier":"https:\/\/i.imgur.com\/ghcxKC0.jpg","alt":null,"variants":[{"traits":["1x","light"],"url":"https:\/\/i.imgur.com\/ghcxKC0.jpg"}]},"doc://AriNote/documentation/AriNote":{"kind":"symbol","type":"topic","identifier":"doc:\/\/AriNote\/documentation\/AriNote","abstract":[{"type":"codeVoice","code":"Today I Learned"}],"url":"\/documentation\/arinote","title":"Ari's Notes","role":"collection"}}}