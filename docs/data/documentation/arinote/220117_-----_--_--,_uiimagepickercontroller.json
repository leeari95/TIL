{"schemaVersion":{"minor":3,"patch":0,"major":0},"identifier":{"interfaceLanguage":"swift","url":"doc:\/\/AriNote\/documentation\/AriNote\/220117_-----_--_--,_UIImagePickerController"},"primaryContentSections":[{"content":[{"anchor":"TIL-Today-I-Learned","type":"heading","text":"TIL (Today I Learned)","level":1},{"type":"paragraph","inlineContent":[{"text":"1월 17일 (월)","type":"text"}]},{"anchor":"%ED%95%99%EC%8A%B5-%EB%82%B4%EC%9A%A9","level":2,"type":"heading","text":"학습 내용"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"UIImagePickerController 사용","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"스위프트의 성능 이해하기"}],"type":"paragraph"}]}]},{"type":"paragraph","inlineContent":[{"type":"text","text":" "}]},{"level":2,"text":"고민한 점 \/ 해결 방법","type":"heading","anchor":"%EA%B3%A0%EB%AF%BC%ED%95%9C-%EC%A0%90--%ED%95%B4%EA%B2%B0-%EB%B0%A9%EB%B2%95"},{"inlineContent":[{"inlineContent":[{"type":"text","text":"[UIImagePicketController]"}],"type":"strong"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"인스턴스를 생성해서 present를 하기만 하면 간단히 앨범이나 카메라에 접근할 수 있는 기능","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"imgePicketController.sourceType을 이용하면 앨범이나, 카메라 접근을 설정할 수 있다."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"sourceType을 .camera로 설정했을 때 시뮬레이터에는 에러가 나므로 주의해야한다.","type":"text"}]},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"text","text":"실제 기기에서만 테스트 가능."}],"type":"paragraph"}]}]}]},{"content":[{"inlineContent":[{"text":"앨범, 카메라 접근권한 설정 방법","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"프로젝트 내에 info 파일을 클릭"}]}]},{"content":[]},{"content":[{"type":"paragraph","inlineContent":[{"text":"이후 우클릭 하여 Add Row를 클릭","type":"text"}]}]},{"content":[]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Privacy를 입력하여 키를 추가해준다. Value에는 알림창에 나오는 메세지를 입력해준다.","type":"text"}]}]},{"content":[]},{"content":[{"inlineContent":[{"text":"UIImagePickerControllerDelegate의 메소드","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"code":"imagePickerController(_ picker:, didFinishPickingMediaWithInfo:)","type":"codeVoice"}]},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"text","text":"이미지를 Picking을 했을 때 불리는 메소드다."}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"선택한 이미지를 앨범에 저장, 혹은 이미지 정보를 활용해 뷰를 구성할 때 주로 사용한다."}]}]}]}]}],"type":"unorderedList"},{"type":"thematicBreak"},{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"[상품 등록 뷰 설계]"}]}]},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"text":"add버튼을 추가해둘 커스텀 Footer를 생성","type":"text"}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"이미지가 5개가 된다면 (collectionView.numberOfItems(inSection: 0) == 5) 플로우 레이아웃 활용해서 푸터 숨김"}]}]}]}]},{"content":[{"inlineContent":[{"type":"text","text":"imageView를 담고있는 커스텀 cell 생성"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"콜렉션뷰에 둘다 레지스터","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"DataSource와 delegateFlowLayout 설정"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"기타 옵션","type":"text"}]},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"text":"스크롤바 숨기기","type":"text"}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"text","text":"collectionView.showsHorizontalScrollIndicator = false"}],"type":"paragraph"}]}]}]},{"content":[{"inlineContent":[{"text":"버튼이나 이미지 cornerRadius 설정","type":"text"}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"text","text":"addButton.layer.cornerRadius = 10"}],"type":"paragraph"}]}]}]}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"image","identifier":"https:\/\/i.imgur.com\/i41dM51.png"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"identifier":"https:\/\/i.imgur.com\/DyzyAOB.png","type":"image"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Footer에 존재하는 버튼을 눌렀을 때 ViewController가 아닌 ","type":"text"},{"type":"codeVoice","code":"FooterView"},{"type":"text","text":"에서 이벤트를 받게 된다."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"NotificationCenter을 활용하여 "},{"code":"버튼 이벤트를 ViewController에게 전달","type":"codeVoice"},{"type":"text","text":"해줄 수 있도록 구성."}]},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"codeVoice","code":"delegate"},{"type":"text","text":" 패턴이랑 둘중에 뭐가 적절한지 비교해봐야지"}],"type":"paragraph"}]}]}]}]},{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"[이벤트를 전달받은 뷰컨이 해야할일 정해보기]"}]}]},{"items":[{"content":[{"inlineContent":[{"code":"UIImagePickerController","type":"codeVoice"},{"type":"text","text":" 인스턴스 생성"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"delegate"},{"text":" 채택","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"편집유무 설정"}]}]},{"content":[{"inlineContent":[{"code":"UIImagePickerController","type":"codeVoice"},{"type":"text","text":" 인스턴스 "},{"type":"codeVoice","code":"present"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"code":"imagePickerController(_ picker:, didFinishPickingMediaWithInfo:)","type":"codeVoice"},{"type":"text","text":" 메소드 구현"}]},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"원본이미지, 수정한 이미지 선언"}]}]},{"content":[{"inlineContent":[{"text":"수정한 이미지가 없다면 원본이미지를 옵셔널 바인딩하도록 설정","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"뷰컨에 있는 images 배열에 append하도록 로직 구성"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"콜렉션뷰를 reloadData"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"picket를 dismiss","type":"text"}]}]}],"type":"unorderedList"}]},{"content":[{"inlineContent":[{"type":"text","text":"콜렉션뷰 "},{"type":"codeVoice","code":"delegate"},{"text":" ","type":"text"},{"code":"didSelectItemAt","type":"codeVoice"},{"text":" 메소드를 활용","type":"text"}],"type":"paragraph"},{"items":[{"content":[{"inlineContent":[{"text":"터치시 이미지를 삭제하도록 구현","type":"text"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"images "},{"type":"codeVoice","code":"remove"},{"text":" 메소드 호출","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"collectionView "},{"code":"reloadData","type":"codeVoice"},{"text":" 호출","type":"text"}],"type":"paragraph"}]}],"type":"unorderedList"}]}],"type":"unorderedList"}]},{"content":[{"inlineContent":[{"type":"text","text":"완성~"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"image","identifier":"https:\/\/i.imgur.com\/SIRf4tB.gif"}]}]},{"content":[{"inlineContent":[{"identifier":"https:\/\/i.imgur.com\/3Lx25s6.gif","type":"image"}],"type":"paragraph"}]}],"type":"unorderedList"},{"inlineContent":[{"type":"strong","inlineContent":[{"text":"[남은 고민거리]","type":"text"}]}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"text","text":"버튼 이벤트 전달할 때 "},{"type":"codeVoice","code":"delegate"},{"text":" vs ","type":"text"},{"code":"NotificationCenter","type":"codeVoice"},{"type":"text","text":" 비교"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"사진이 추가될 때 마다 콜렉션뷰 자동 스크롤이 필요할듯","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"사진을 터치할 때 삭제하겠냐고 물어보는 얼럿 추가 구현 필요할듯"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"사진을 추가할 때 카메라, 앨범 선택하는 얼럿시트 띄우고 싶은데… 소스타입을 카메라로 바꾸면 에러가 나서 해결못함 (소스타입을 사용할 수 없담서…)"}]},{"items":[{"content":[{"inlineContent":[{"type":"text","text":"아 이건.. 시뮬레이터에서 카메라를 열라그래서 뜨는 에러란다. 실제 기기에서는 잘 작동하나보다."}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"카메라는 사실 요구사항에 없는 부분이라 제리랑 의논해봐야징"}],"type":"paragraph"}]}],"type":"unorderedList"}]}]},{"type":"thematicBreak"},{"inlineContent":[{"type":"strong","inlineContent":[{"text":"[스위프트 성능 이해하기]","type":"text"}]}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Value Semantics"}]},{"items":[{"content":[{"inlineContent":[{"type":"text","text":"Value Type Semantic \/ Copy by Value Semantic"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"identity가 아닌 Value(값)에만 의미를 둔다."}]},{"items":[{"content":[{"inlineContent":[{"text":"Int, Double 등의 기본 타입","type":"text"}],"type":"paragraph"}]}],"type":"unorderedList"}]},{"content":[{"inlineContent":[{"text":"포인터만 복사되는 참조(Reference) 시맨틱스와 비교된다.","type":"text"}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"text","text":"Objective-C, Java 등"}],"type":"paragraph"}]}]}]},{"content":[{"inlineContent":[{"text":"스위프트엔 Objc에 없던 새로운 Value 타입을 도입","type":"text"}],"type":"paragraph"},{"items":[{"content":[{"inlineContent":[{"type":"text","text":"struct, enum, tuple"}],"type":"paragraph"}]}],"type":"unorderedList"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"특징"}]},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"text","text":"변수 할당 시 Stack에 값 전체가 저장된다."}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"다른 변수에 할당될 때 전체 값이 복사된다. (copy by value)","type":"text"}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"text":"변수들이 분리된다. 하나를 변경해도 다른 것에 영향이 없다.","type":"text"}],"type":"paragraph"}]}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Heap을 안쓰며 Reference Counting도 필요없다."}]}]}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"class vs struct","type":"text"}]},{"type":"unorderedList","items":[{"content":[]},{"content":[{"type":"paragraph","inlineContent":[{"text":"클래스는 하나의 identity 변수가 복사되어도 값이 하나를 향해 같은 값을 가진다.","type":"text"}]}]},{"content":[]},{"content":[{"inlineContent":[{"text":"값타입의 각자 변수는 복사되어도 분리되어있다.","type":"text"}],"type":"paragraph"}]}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Value Semantics: 값에 의해 구분된다.","type":"text"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"Value semantic에서는 identity가 아니라 value가 중요하다.","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"각 변수는 값(value)에 의해 구분이 되어야 한다."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"따라서 동치 관계여야 한다.","type":"text"}]},{"type":"unorderedList","items":[{"content":[]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"간단하다. Equatable을 구현하자. (단순히 데이터를 전달할 목적인 struct 변수를 말하는 것이 아님)"}]}]}]}]}]}]},{"content":[{"inlineContent":[{"text":"Value Type과 Thread","type":"text"}],"type":"paragraph"},{"items":[{"content":[]},{"content":[{"inlineContent":[{"text":"스레드 간 의도하지 않은 공유로부터 안전하다.","type":"text"}],"type":"paragraph"}]}],"type":"unorderedList"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"값 모두를 Copy하는데 성능은 괜찮을까?"}]},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"text","text":"Copy는 빠르다"}],"type":"paragraph"},{"items":[{"content":[{"inlineContent":[{"type":"text","text":"기본 타입들 enum tuple struct"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"정해진 시간(constant time)안에 끝난다."}]}]}],"type":"unorderedList"}]},{"content":[{"inlineContent":[{"type":"text","text":"내부 데이터가 Heap과 혼용하는 struct의 경우"}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"text":"정해진 시간 + 래퍼런스 copy등의 시간","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"String, Array Set, Dictionary 등"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"쓰기 시 Copy-on-write로 속도 저하 보완"}]}]}]}]}],"type":"unorderedList"}]}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"스레드로 문제 생기는 것을 Immutable로 해도 되는것이 아닌가?","type":"text"}]},{"items":[{"content":[{"inlineContent":[{"type":"text","text":"사실 immutable로 해도되지만 모두 다 잘되는 것은 아니다."}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"참조형이어도 값이 불변하면 Thread간에 문제생길 일이 없다.","type":"text"}]}]},{"content":[{"inlineContent":[{"text":"함수형 패러다임과 같이 널리 전파되기도 하였다.","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Immutable은 cocoa에서도 꽤 써왔다.","type":"text"}]}]}],"type":"unorderedList"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"정말 Immutable이 언제나 답일까?"}]},{"items":[{"content":[{"inlineContent":[{"text":"답은 아니다.","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Objc에서 많이 쓰던 Immutable 방식","type":"text"}]}]},{"content":[]},{"content":[{"type":"paragraph","inlineContent":[{"text":"비효율적이다.","type":"text"}]}]},{"content":[]},{"content":[]},{"content":[]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Dashboard를 새로 갈아끼는 것인가?"}]}]}],"type":"unorderedList"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"그래도 class도 중요한 경우"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"value보다 identity가 중요한 경우"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"UIView 같이 모든 변수에서 단 하나의 state를 갖는 개체"}]}]}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"OOP 모델"}]},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"여전히 상속은 아주 훌륭한 도구"}]}]}],"type":"unorderedList"}]},{"content":[{"inlineContent":[{"type":"text","text":"Objective-C 연동"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Indirect storage (특수한 경우 struct내의 간접 저장소 역할)","type":"text"}]}]}]}]}],"type":"unorderedList"}]},{"content":[{"inlineContent":[{"text":"성능을 위해 고려할 것들","type":"text"}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"성능에 영향을 미치는 3가지"}]},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Memory Allocation"}]},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"Stack or Heap","type":"text"}]}]}],"type":"unorderedList"}]},{"content":[{"inlineContent":[{"type":"text","text":"Reference Counting"}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"No or Yes"}]}]}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Method Dispatch","type":"text"}]},{"items":[{"content":[{"inlineContent":[{"type":"text","text":"Static or Dynamic"}],"type":"paragraph"}]}],"type":"unorderedList"}]}],"type":"unorderedList"}]},{"content":[{"inlineContent":[{"text":"Heap 할당의 문제","type":"text"}],"type":"paragraph"},{"items":[{"content":[{"inlineContent":[{"type":"text","text":"할당 시에 빈 곳을 찾고 관리하는 것이 복잡한 과정이다."}],"type":"paragraph"}]},{"content":[]},{"content":[{"type":"paragraph","inlineContent":[{"text":"무엇보다 그 과정이 thread safe해야 한다는 점이 가장 큰 문제이다.","type":"text"}]},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"lock 등의 synchronization 동작은 큰 성능 저하 요소","type":"text"}]}]}],"type":"unorderedList"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"반면 Stack 할당은?"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"단순히 스택포인터 변수값만 바꿔주는 정도","type":"text"}]}]}]}]}],"type":"unorderedList"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Heap 할당 줄이기","type":"text"}]},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"heap 할당 줄이기 최적화 예제"}]}]},{"content":[]},{"content":[{"inlineContent":[{"type":"text","text":"매우 번번히 호출된다면 성능에 영향을 미칠 수 있다."}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"예를 들면 매우 큰 Loop 안에서 일어나는 경우"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"Key를 Value type으로 바꿔보자.","type":"text"}]}]},{"content":[]},{"content":[]}]}]}],"type":"unorderedList"}]}],"type":"unorderedList"}]},{"content":[{"inlineContent":[{"text":"Reference Counting의 문제","type":"text"}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"text","text":"정말 자주 실행된다."}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"text","text":"변수 Copy할 때 마다"}],"type":"paragraph"}]}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"그러나 이것도 역시 가장 큰 문제는 Thread Safety 때문"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"카운트를 Atomic하게 늘리고 줄여야한다.","type":"text"}]}]}]}]}]}]},{"content":[{"inlineContent":[{"type":"text","text":"Method Dispatch"}],"type":"paragraph"},{"items":[{"content":[{"inlineContent":[{"type":"text","text":"Static"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"컴파일 시점에 메소드의 실제 코드 위치를 안다면 실행중 찾는 과정 없이 바로 해당 코드 주소로 점프할 수 있음"}]}]},{"content":[{"inlineContent":[{"text":"컴파일러의 최적화, 메소드 인라이닝(Inlining) 가능","type":"text"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"메소드 인라이닝?","type":"text"}]},{"items":[{"content":[{"inlineContent":[{"text":"컴파일 시점에 메소드 호출 부분에 메소드 내용을 붙여넣는다.","type":"text"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"효과가 있다고 판단하는 경우에만","type":"text"}]}]}],"type":"unorderedList"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Call Stack 오버헤드 줄임","type":"text"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"CPU icache나 레지스터를 효율적으로 쓸 가능성"}]}]}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"컴파일러의 추가 최적화 가능"}]},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"최근 메소드들이 작으므로 더더욱 기회가 많다."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"루프 안에서 불리는 경우 큰 효과","type":"text"}]}]}],"type":"unorderedList"}]}],"type":"unorderedList"}]}],"type":"unorderedList"}]}],"type":"unorderedList"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Dynamic"}]},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"Reference 시맨틱스에서의 다형성(Polymorphism)","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"실제 타입을 컴파일 시점에 알 수가 없다. 때문에 코드 주소를 rutime에 찾아야 한다."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Dynamic Method Dispatch의 문제"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"Static에 비해 단지 이것이 문제. Thread Safety문제도 없다.","type":"text"}]}]},{"content":[{"inlineContent":[{"text":"하지만 이로 인해 컴파일러가 최적화를 못하는 것이 큰 문제이다.","type":"text"}],"type":"paragraph"}]}]}]},{"content":[{"inlineContent":[{"text":"Static Dispatch로 강제하기","type":"text"}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"final, private 등을 쓰는 버릇"}]},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"해당 메소드, 프로퍼티등은 상속되지 않으므로 static하게 처리"}]}]}],"type":"unorderedList"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"dynamic을 쓰지 않는다.","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Objc 연동 최소화"}]},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"text":"Objective-C Runtime을 통하게 된다.","type":"text"}],"type":"paragraph"}]}]}]},{"content":[{"inlineContent":[{"text":"WMO(whole module optimization)","type":"text"}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"text","text":"빌드시에 모든 파일을 한번에 분석하여 static dispatch로 변환 가능한지 등을 판단하여 최적화해준다."}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"text","text":"하지만 굉장히 느려진다…"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"디버그 빌드에 적용하는 것은 정신건강에 좋지 않다.","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"아직 안정화가 안되어있다.","type":"text"}]}]}]}]}]}]}]}]}],"type":"unorderedList"}]}],"type":"unorderedList"}]},{"content":[{"inlineContent":[{"type":"text","text":"정리"}],"type":"paragraph"}]},{"content":[]}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"스위프트의 추상화 기법들의 성능"}]},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"text","text":"추상화 기법들"}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"class","type":"text"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"클래스는 Heap과 Referencs Counting을 이용한다."}]}]},{"content":[]},{"content":[{"type":"paragraph","inlineContent":[{"text":"성능 상관 없이 래퍼런스 시맨틱스가 필요하다면 써야함","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Identity, 상속 등등…","type":"text"}]},{"items":[{"content":[{"inlineContent":[{"text":"단 래퍼런스의 의도하지않은 공유로 인한 문제는 조심해야 한다.","type":"text"}],"type":"paragraph"}]}],"type":"unorderedList"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"단 클래스에 final 키워드를 쓴다면?","type":"text"}]}]},{"content":[]},{"content":[{"inlineContent":[{"type":"text","text":"method Dispatch가 Static이 되서 이 부분에 대한 성능이 개선될 수 있다."}],"type":"paragraph"}]}]}]},{"content":[{"inlineContent":[{"text":"struct","type":"text"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"구조체안에 어떤 타입이 들어가 있는지에 따라 성능이 크게 달라진다.","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"참조 타입이 없다면?"}],"type":"paragraph"}]},{"content":[]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"참조 타입을 가진 구조체라면?"}]}]},{"content":[]},{"content":[]},{"content":[]},{"content":[{"inlineContent":[{"text":"Reference Counting이 한번 Copy할 때마다 2번씩 일어난다.","type":"text"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"struct안에 참조 타입의 property 수 만큼 많아진다.","type":"text"}]}]},{"content":[]}],"type":"unorderedList"}]},{"content":[{"inlineContent":[{"type":"text","text":"참조 타입을 많이 가지고있는 구조체는?"}],"type":"paragraph"}]},{"content":[]},{"content":[{"inlineContent":[{"text":"구조체 내 참조타입을 줄여보기","type":"text"}],"type":"paragraph"}]},{"content":[]}],"type":"unorderedList"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"protocol"}]},{"items":[{"content":[{"inlineContent":[{"type":"text","text":"코드 없이 API만 정의한다."}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"상속 없는 다형성(Polymorphism) 구현이 가능하다."}]}]},{"content":[{"inlineContent":[{"text":"Objective C의 protocol, Java의 Interface 매우 유사함","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Value 타입인 struct에도 적용이 가능하다.","type":"text"}]},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"value semantics에서의 다형성","type":"text"}]}]}],"type":"unorderedList"}]},{"content":[{"inlineContent":[{"type":"text","text":"protocol을 이용한 값타입의 다형성"}],"type":"paragraph"}]},{"content":[]},{"content":[{"type":"paragraph","inlineContent":[{"text":"의문점","type":"text"}]},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"text":"변수 할당","type":"text"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"클래스라면 주소값이니 모두 같은 사이즈지만 구조체인 Point와 Line은 사이즈가 다르다.","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"어떻게 Drawable에 메모리를 미리 할당해 놓고 값을 저장할까?","type":"text"}]}]}],"type":"unorderedList"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Method Dispatch"}]},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"text","text":"클래스의 다형성 구조에선 V-Table을 통해서 찾았다."}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"상속이 아닌 protocol의 다형성 구조에선 V-Table이 없다.","type":"text"}]}]},{"content":[{"inlineContent":[{"text":"어떻게 Point-draw와 Line.draw를 구분해서 호출할까?","type":"text"}],"type":"paragraph"}]}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"프로토콜의 변수할당"}]}]},{"content":[]},{"content":[{"type":"paragraph","inlineContent":[{"text":"이것을 해결하기 위해서 Existential Container을 활용한다.","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"실제 값을 넣고 관리하는 구조"}],"type":"paragraph"}]},{"content":[]},{"content":[{"inlineContent":[{"text":"struct가 3 words 이하인 경우","type":"text"}],"type":"paragraph"}]},{"content":[]},{"content":[{"type":"paragraph","inlineContent":[{"text":"struct가 3 words보다 큰 경우","type":"text"}]}]},{"content":[]},{"content":[{"inlineContent":[{"text":"어떻게 3 word를 구분해 할당하고 복사하지?","type":"text"}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"text":"Value Witness Table(VWT)를 사용한다.","type":"text"}],"type":"paragraph"}]},{"content":[]}]}]},{"content":[{"inlineContent":[{"text":"VWT","type":"text"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Existential container의 생성\/해제를 담당하는 인터페이스이다."}]}]},{"content":[]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"protocol을 구현하는 타입마다 있다."}]}]}],"type":"unorderedList"}]},{"content":[{"inlineContent":[{"text":"protocol Witness Table","type":"text"}],"type":"paragraph"}]},{"content":[]}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Copy 동작 정리","type":"text"}]},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"text":"value 타입이므로 값 전체가 복사된다.","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"3words 이하인 경우","type":"text"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"단순히 새로운 Existential container에 전체가 복사됨"}]}]}],"type":"unorderedList"}]},{"content":[{"inlineContent":[{"text":"3 words를 넘는 경우","type":"text"}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"새로운 Existential container 생성","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"힙에 할당되어 저장된 값 전체가 새로운 힙 할당후 복사된다."}]}]}]}]}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"큰 사이즈 protocol 타입의 copy","type":"text"}]}]},{"content":[]},{"content":[{"inlineContent":[{"type":"text","text":"개선해본다면?"}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"스토리지 클래스를 만든다."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"그렇게 된다면 Drawable을 할당할 때 스토리지의 Reference를 가져오게 되는 것이다.","type":"text"}]}]},{"content":[]},{"content":[{"inlineContent":[{"text":"따라서 힙 할당이 더 싼 Reference Counting으로 바뀌었다.","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"하지만 값을 바꾼다면?","type":"text"}],"type":"paragraph"}]},{"content":[]},{"content":[]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"value타입인데 이러면 안된다."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"따라서 이런 경우에는 값을 할당할 때 새로운 스토리지를 복사하여 대입하도록 코드를 추가해주어야 한다."}]}]},{"content":[]},{"content":[{"type":"paragraph","inlineContent":[{"text":"이거에 대한 큰 장점은 일반적으로 사용할 때는 전혀 메모리 할당이 추가적으로 일어나지 않지만, 쓸때에만 복사를 한다. 따라서 성능을 개선할 수가 있다.","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Existential Container"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"변수가 protocol 타입으로 정의된 경우 쓰인다."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"프로토콜을 통한 더형성을 구현하기 위한 목적으로 쓰인다."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"내부 동작이 복잡하긴 해도 성능이 class 쓰는 것과 비슷하다."}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"둘다 초기화 시 Heap 할당하여 사용"}]}]},{"content":[{"inlineContent":[{"text":"둘다 Dynamic dispatch (class 도 V-Type, protocol은 PWT)","type":"text"}],"type":"paragraph"}]}]}]}]}]},{"content":[{"inlineContent":[{"type":"text","text":"하지만 복사를 할때에는 다른데.."}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"큰 사이즈 Protocol 타입의 copy","type":"text"}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"Indirect Storage","type":"text"}]},{"items":[{"content":[{"inlineContent":[{"text":"복사 시 힙 할당 대신 Reference Counting으로 대체","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"class타입의 다형성 쓸때와 비슷한 수준"}],"type":"paragraph"}]}],"type":"unorderedList"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Copy-on-Write","type":"text"}]},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"text","text":"Indirect storage를 값이 변경될 시점에 Heap 할당하여 복사"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"성능 저하를 최소화한다. (변경 동작에서만)","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"String, Array, Dictionary 등도 이런 개념으로 Value semantics를 구현한다.","type":"text"}]}]}]}]},{"content":[{"inlineContent":[{"text":"작은 사이즈의 protocol 타입","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"image","identifier":"https:\/\/user-images.githubusercontent.com\/75905803\/149803520-5e5366cd-948f-481b-b0d3-455e0a0e5e10.png"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"큰 사이즈의 protocol 타입","type":"text"}]}]},{"content":[]}]}]}]}]}],"type":"unorderedList"}]},{"content":[{"inlineContent":[{"text":"Generics","type":"text"}],"type":"paragraph"},{"items":[{"content":[{"inlineContent":[{"type":"text","text":"제네릭 타입도 프로토콜과 마찬가지로 VWT를 사용한다."}],"type":"paragraph"}]},{"content":[]},{"content":[]},{"content":[{"type":"paragraph","inlineContent":[{"text":"성능을 개선할 수 없을까?","type":"text"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Method 내에서는 Drawble의 실제 타입이 바뀌지 않는다."}]},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Static Polymorphism"}]}]}],"type":"unorderedList"}]},{"content":[{"inlineContent":[{"type":"text","text":"실제 타입별로 메소드를 만들어 준다면?"}],"type":"paragraph"}]},{"content":[]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"하지만 이걸 손으로 하면 Generics 쓰지 말란 말인가?"}]},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"text","text":"ㄴㄴ 컴파일러가 해준다."}],"type":"paragraph"}]}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Generic 특수화(Specialization)"}]},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"text","text":"더 효과를 보려면 WMO(whole module Optimization)을 켜라"}],"type":"paragraph"}]},{"content":[]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"아직 너무 믿진 말자…"}]}]}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"제네릭 타입 정리"}]},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"text":"정적 다형성(Static Polymorphism)","type":"text"}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"text","text":"컴파일 시점에 부르는 곳마다 타입이 정해져있다."}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"런타임에 바뀌지 않는다.","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"특수화(Specialization)가 가능하다."}],"type":"paragraph"}]}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"특수화가 되지 않은 제네릭(작은 사이즈)"}]}]},{"content":[]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"특수화된 제네릭(작은 사이즈)"}]}]},{"content":[]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"특수화가 되지 않은 제네릭(큰 사이즈)"}]}]},{"content":[]},{"content":[{"type":"paragraph","inlineContent":[{"text":"특수화된 제네릭(큰 사이즈)","type":"text"}]}]},{"content":[]}]}]}]}]}],"type":"unorderedList"}]}]}]},{"content":[{"inlineContent":[{"type":"text","text":"스위프트 성능 이해 정리"}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"text":"Objective-C에 비해 큰 향상이 있었으나 값타입과 프로토콜 타입 등의 성격을 고려해야 한다.","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"성능 최적화를 고려해야하는 경우의 예","type":"text"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"렌더링 관련 로직 등 반복적으로 매우 빈번히 불리는 경우","type":"text"}]}]},{"content":[{"inlineContent":[{"text":"서버 환경에서의 대용량 데이터 처리","type":"text"}],"type":"paragraph"}]}],"type":"unorderedList"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"추상화 기법의 선택","type":"text"}]},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"text":"struct","type":"text"}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"text","text":"엔티티 등 value 시맨틱이 맞는 부분"}],"type":"paragraph"}]}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"class"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"identity가 필요한 부분, 상속등의 OOP, Objective-C"}]}]}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"generics"}]},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"정적 다형성으로 가능한 경우","type":"text"}]}]}],"type":"unorderedList"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"protocol","type":"text"}]},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"text","text":"동적 다형성이 필요한 경우"}],"type":"paragraph"}]}]}]}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"고려할 수 있는 성능 최적화 기법"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"struct에 클래스 타입의 프로퍼티가 많으면","type":"text"}]},{"items":[{"content":[{"inlineContent":[{"type":"text","text":"enum, struct 등 값타입으로 대체"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Reference Counting을 줄인다."}]}]}],"type":"unorderedList"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Protocol 타입을 쓸 때 대상이 큰 struct이면"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Indirect storage로 struct 구조 변경"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"mutable해야하면 copy-on-write 구현"}],"type":"paragraph"}]}]}]},{"content":[{"inlineContent":[{"type":"text","text":"Dynamic method dispatch를 static하게"}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"final, private의 생활화"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"dynamic 사용 최소화"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Objc 연동 최소화 하기"}]}]}]}]}]}]}]}]}]}]}],"type":"unorderedList"},{"type":"thematicBreak"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"참고링크","type":"text"}]},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"text","text":"https:\/\/jinshine.github.io\/2018\/07\/06\/iOS\/UIImagePickerController%20%EC%98%88%EC%A0%9C\/"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"https:\/\/zeddios.tistory.com\/949"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"https:\/\/hururuek-chapchap.tistory.com\/64"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"https:\/\/developer.apple.com\/videos\/play\/wwdc2016\/416\/"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"https:\/\/developer.apple.com\/swift\/blog\/?id=27","type":"text"}]}]}]}]}]}],"kind":"content"}],"sections":[],"variants":[{"paths":["\/documentation\/arinote\/220117_-----_--_--,_uiimagepickercontroller"],"traits":[{"interfaceLanguage":"swift"}]}],"hierarchy":{"paths":[["doc:\/\/AriNote\/documentation\/AriNote","doc:\/\/AriNote\/documentation\/AriNote\/UIKit"]]},"kind":"article","metadata":{"role":"article","roleHeading":"Article","modules":[{"name":"Ari's Notes"}],"title":"220117 스위프트의 성능 이해, UIImagePickerController"},"references":{"https://i.imgur.com/3Lx25s6.gif":{"identifier":"https:\/\/i.imgur.com\/3Lx25s6.gif","alt":null,"variants":[{"url":"https:\/\/i.imgur.com\/3Lx25s6.gif","traits":["1x","light"]}],"type":"image"},"https://i.imgur.com/DyzyAOB.png":{"identifier":"https:\/\/i.imgur.com\/DyzyAOB.png","alt":null,"variants":[{"url":"https:\/\/i.imgur.com\/DyzyAOB.png","traits":["1x","light"]}],"type":"image"},"https://user-images.githubusercontent.com/75905803/149803520-5e5366cd-948f-481b-b0d3-455e0a0e5e10.png":{"identifier":"https:\/\/user-images.githubusercontent.com\/75905803\/149803520-5e5366cd-948f-481b-b0d3-455e0a0e5e10.png","alt":"image","variants":[{"url":"https:\/\/user-images.githubusercontent.com\/75905803\/149803520-5e5366cd-948f-481b-b0d3-455e0a0e5e10.png","traits":["1x","light"]}],"type":"image"},"doc://AriNote/documentation/AriNote":{"kind":"symbol","type":"topic","identifier":"doc:\/\/AriNote\/documentation\/AriNote","abstract":[{"type":"codeVoice","code":"Today I Learned"}],"url":"\/documentation\/arinote","title":"Ari's Notes","role":"collection"},"doc://AriNote/documentation/AriNote/UIKit":{"kind":"article","title":"UIKit","abstract":[{"type":"text","text":"한몸이 되보자…"}],"type":"topic","role":"collectionGroup","identifier":"doc:\/\/AriNote\/documentation\/AriNote\/UIKit","url":"\/documentation\/arinote\/uikit"},"https://i.imgur.com/SIRf4tB.gif":{"identifier":"https:\/\/i.imgur.com\/SIRf4tB.gif","alt":null,"variants":[{"url":"https:\/\/i.imgur.com\/SIRf4tB.gif","traits":["1x","light"]}],"type":"image"},"https://i.imgur.com/i41dM51.png":{"identifier":"https:\/\/i.imgur.com\/i41dM51.png","alt":null,"variants":[{"url":"https:\/\/i.imgur.com\/i41dM51.png","traits":["1x","light"]}],"type":"image"}}}