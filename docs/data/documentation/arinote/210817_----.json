{"variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/documentation\/arinote\/210817_----"]}],"primaryContentSections":[{"kind":"content","content":[{"anchor":"TILToday-I-Learned","text":"TIL(Today I Learned)","level":1,"type":"heading"},{"type":"paragraph","inlineContent":[{"type":"text","text":"날짜: 2021년 8월 17일"},{"text":" ","type":"text"},{"type":"text","text":"작성자: 이아리"},{"type":"text","text":" "},{"text":"태그: Protocol, 프로토콜","type":"text"}]},{"text":"학습내용","anchor":"%ED%95%99%EC%8A%B5%EB%82%B4%EC%9A%A9","level":2,"type":"heading"},{"type":"paragraph","inlineContent":[{"text":"오늘은 프로토콜에 대해서 알아보는 시간을 가졌다. 공부할 내용이 산더미이다. 메서드 부분까지만 배우고 이니셜라이저 관련한 프로토콜 채택방법도 배워야한다. 과제 3-3도 제출하긴 했으나 많이 모자른 것 같다. 내가 할 수 있는 최선을 다해 작성을 해보았는데, 설계 과정이 쉬운일이 아니라는 걸 새삼 깨달았다. 나름 그래도 정리해서 설계해보겠다고 메모장에 만들 프로퍼티랑 메서드를 적어가며 코드를 작성해보았는데… 작성할때마다 계속 수정을 해야하는[?]…. 코드에 손이 많이갔다. 그만큼 설계과정에서 완벽하지 못했다는 이야기겠지… 설계하는 과정에서도 아직 이니셜라이저, 프로퍼티, 메서드 부분 개념이 완벽하지 못하다는 것도 알게되었다. ‘뭐 이정도면 다 아는거겠지!!?’ 라고 생각하고 있었는데, 그것은 오산이였다. 그래서 심화과제를 풀어가면서 프로퍼티와 메서드, 이니셜라이저 부분을 다시한번 복습했다. 봐도봐도 익숙해지지가 않는데, 계속 복습 하다보면 고수가 되는 날이 오겠지…","type":"text"}]},{"text":"정리","type":"heading","anchor":"%EC%A0%95%EB%A6%AC","level":2},{"type":"paragraph","inlineContent":[{"text":"오늘 정리는 과제를 하느라 프로토콜만 간신히 정리하였다. 그 마저도 다한게 아니라 메서드 부분까지만 정리해서 아직 미완성이다. 과제랑 글쓰기를 같이 하려니까 많이 벅차네…","type":"text"}]},{"text":"프로토콜이란?","level":3,"anchor":"%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C%EC%9D%B4%EB%9E%80","type":"heading"},{"inlineContent":[{"text":"프로토콜(Protocol)은 인터페이스이다. 최소한으로 가져야할 속성이나 메서드를 정의해줄 수 있다. 구현은 하지않고 정의만 하는게 특징이다.","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"클래스와 구조체에 프로토콜을 적용시킬 수 있다. 프로토콜을 적용하면 프로토콜에서 정의한 속성과 메서드를 모두 구현해야 한다.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"하나의 타입으로 사용되기 때문에 아래와 같이 타입 사용이 허용되는 모든 곳에 프로토콜을 사용할 수 있다.","type":"text"}]},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"text":"함수, 메소드, 이니셜라이저의 파라미터 타입 혹은 리턴 타입","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"상수, 변수, 프로퍼티의 타입"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"배열, 딕셔너리의 원소타입"}]}]}]},{"inlineContent":[{"type":"text","text":"기본형태"}],"type":"paragraph"},{"syntax":"swift","code":["protocol name {","    \/\/ 프로토콜 정의","}"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"구조체, 클래스, 열거형 등에서 프로토콜을 채택하려면 타입 이름 뒤에 콜론”:”을 붙여준 후 채택할 프로토콜 이름을 쉼표”,”로 구분하여 명시해준다. SubClass의 경우 SuperClass를 가장 앞에 명시한다."}]},{"syntax":"swift","type":"codeListing","code":["struct SomeStruct: AProtocol, AnotherProtocol {"," \/\/ 구조체 정의","}","\/\/ 상속받는 클래스의 프로토콜 채택","class SomeClass: SuperClass, AProtocol, AnotherProtocol {"," \/\/ 클래스 정의","}"]},{"type":"paragraph","inlineContent":[{"text":"프로토콜을 생성할때 AnyObject를 상속하게되면 클래스 전용 프로토콜로 정의해줄 수 있다.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"구조체나 열거형에서는 채택할 수 없는 프로토콜이 된다."}]},{"code":["protocol Protocols { \/\/ Upper Camel Case","    \/\/ property Requirements","    \/\/ method Requirements","    \/\/ initializer Requirements","    \/\/ subscript Requirements","}","","protocol Name: Protocols {","    \/\/ 프로토콜은 상속을 지원한다. 클래스와 문법은 동일하다.","    \/\/ 클래스와 다르게 다중상속을 지원한다.","}","","protocol Test {","    func say()","}","","struct A: Test {","    func say() {","        \/\/ 구현부는 자유롭게 작성할 수 있다.","        print(\"난 말할 수 있다!!!\")","    }","}","","protocol OnlyClass: AnyObject, Test {","    \/\/ 클래스 전용 프로토콜로 선언된다.","    \/\/ 구조체나 열거형에서는 채택할 수 없다.","}","","\/\/struct Value: OnlyClass {","\/\/    \/\/ error: non-class type 'Value' cannot conform to class protocol 'OnlyClass'","\/\/}","class Reference: OnlyClass {","    \/\/ OnlyClass 프로토콜은 AnyObject외에 Test 프로토콜도 상속받고 있다.","    func say() { \/\/ 그래서 Test의 정의되어있는 메서드 구현이 필요하다","        print(\"난 클래스야, 참조타입임!!!\")","    }","}"],"type":"codeListing","syntax":"swift"},{"level":3,"anchor":"Property-Requirments","type":"heading","text":"Property Requirments"},{"inlineContent":[{"type":"text","text":"프로토콜에서는 프로퍼티가 저장프로퍼티인지 연산프로퍼티인지 명시하지 않고, 이름과 타입 그리고 gettable, settable한지 명시한다. 프로퍼티는 항상 var로 선언해야 한다. 프로토콜에서의 var 키워드는 가변성과는 아무런 관계가 없다. 대신 선언하는 멤버가 프로퍼티라는 것을 나타낸다."}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["protocol Protocols { ","    var name: String { get set }","    static var age: Int { get set }","}"]},{"type":"paragraph","inlineContent":[{"text":"get과 set이 모두 포함되어있다면 형식에서 읽기와 쓰기가 가능한 프로퍼티로 구현해야하고, get만 포함되어있는 경우에는 읽기 가능하도록 구현하면 된다.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"타입 프로퍼티로 선언할때는 var 키워드 앞에 static을 추가해주면 된다.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"get만 설정해주었을 때"}]},{"syntax":"swift","code":["protocol Test {","    var name: String { get }","}","","struct A: Test {","    var name: String \/\/ 읽기만 가능하도록 구현","}","struct B: Test {","    var name: String = \"Ari Lee\" \/\/ 반드시 읽기만 가능하도록 구현하지 않아도 된다.","}"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"get set 둘다 설정해주었을 때"}]},{"type":"codeListing","syntax":"swift","code":["protocol TestT {","    var name: String { get set }","}","","struct C: TestT {","    \/*","     let name: String = \"Ari Lee\" note: candidate is not settable, but protocol requires it","     ~~~ ^","     var","     *\/","    var name: String = \"Ari Lee\" \/\/ 읽기 쓰기 모두 가능해야하기 때문에 let 선언은 불가하다.","}","struct D: TestT {","    var name: String {","        get {","           return \"Ari Lee\"","        }","        set {","            ","        }","    }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"static을 이용하여 타입 프로퍼티를 정의해줬을 때."},{"text":" ","type":"text"},{"text":"주의 : 클래스 안에 static키워드로 선언된 프로퍼티는 서브클래스로 상속은 가능하지만 오버라이딩은 불가능하다. 따라서 오버라이딩을 허용하려면 static 대신 class 타입으로 선언해줘야 한다.","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["protocol TestTe {","    static var name: String { get set }","}","","struct E: TestTe {","    static var name: String = \"Ari Lee\" \/\/ 프로퍼티 앞에 타입을 필수적으로 추가해줘야 한다.","}","","class F: TestTe {","\/\/    static var name: String {","\/\/        get {","\/\/            return \"Ari Lee\"","\/\/        }","\/\/        set {","\/\/","\/\/        }","\/\/    }","\/\/    static 타입은 상속은 가능하지만 오버라이딩은 불가능하다","    ","    class var name: String {","\/\/ static에서 class로 변경하여도 여전히 타입 프로퍼티이다. 이름과 자료형, 가변성도 동일하다.","        get {","            return \"Ari Lee\"","        }","        set {","            ","        }","    }","\/\/ 그래서 프로토콜의 요구사항을 충족시킨다. 서브클래스에서 오버라이딩하는 것도 가능하다.","}"]},{"level":3,"text":"Method Requirements","type":"heading","anchor":"Method-Requirements"},{"code":["protocol Protocols {","    func A(param: Int) -> Int","    static func B(param: String) -> String","    mutating func C(param: Double) -> Double \/\/ 값타입 전용은 아니다. 참조타입에서도 채택가능하다.","}"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"프로토콜은 메서드 이름, 파라미터 이름과 타입, 리턴 타입만 정의한다."}]},{"type":"paragraph","inlineContent":[{"text":"채택하여 메서드를 구현할때 구현부는 자유롭게 작성할 수 있다.","type":"text"}]},{"syntax":"swift","type":"codeListing","code":["protocol Talk {","    func say()","}","","class A: Talk {","    func say() {","        print(\"난 클래스 A라고 해.\")","    }","}"]},{"inlineContent":[{"text":"만약 구조체안에 메서드가 프로퍼티의 값을 바꾸려한다면 mutating 키워드를 붙여줘야 한다.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"그럼 프로토콜도 마찬가지로 mutating 키워드를 추가해줘야 한다."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"이때 클래스는 참조타입이기 때문에 mutating 키워드를 메서드 앞에 붙여주지 않아도 프로토콜 요구사항을 충족시키기 때문에 에러가 발생하지 않는다."}]},{"inlineContent":[{"type":"text","text":"예제"}],"type":"paragraph"},{"type":"codeListing","code":["protocol renamed {","    mutating func newName()","}","","struct A: renamed {","    var name: String = \"Ari\"","    mutating func newName() {","        name = \"three\"","    }","}","","class B: renamed {","    var name: String = \"Ari\"","    func newName() {","        name = \"three\"","    }","}"],"syntax":"swift"},{"inlineContent":[{"type":"text","text":"오버로딩 규칙에 따라서 이름이 동일한 메서드를 인스턴스 메서드와 타입 메서드로 동시에 구현할 수도 있다."}],"type":"paragraph"},{"type":"codeListing","code":["protocol Test {","    static func test()","}","","class C: Test {","    var number = 0","    func test() {","        number = 10","    }","    ","\/\/    static func test() {","\/\/        \/\/ 이 메서드는 서브클래스에 상속은 가능하지만 오버라이딩은 불가능하다.","\/\/    }","    ","    class func test() {","        \/\/ 이 메서드는 프로토콜을 충족하면서 상속과 오버라이딩도 가능하다.","    }","}"],"syntax":"swift"}]}],"hierarchy":{"paths":[["doc:\/\/AriNote\/documentation\/AriNote","doc:\/\/AriNote\/documentation\/AriNote\/Swift"]]},"identifier":{"url":"doc:\/\/AriNote\/documentation\/AriNote\/210817_----","interfaceLanguage":"swift"},"schemaVersion":{"minor":3,"major":0,"patch":0},"metadata":{"role":"article","roleHeading":"Article","title":"210817 프로토콜","modules":[{"name":"Ari's Notes"}]},"kind":"article","sections":[],"references":{"doc://AriNote/documentation/AriNote/Swift":{"identifier":"doc:\/\/AriNote\/documentation\/AriNote\/Swift","role":"collectionGroup","abstract":[{"type":"text","text":"언어 공부"}],"kind":"article","title":"Swift","url":"\/documentation\/arinote\/swift","type":"topic"},"doc://AriNote/documentation/AriNote":{"kind":"symbol","type":"topic","identifier":"doc:\/\/AriNote\/documentation\/AriNote","abstract":[{"type":"codeVoice","code":"Today I Learned"}],"url":"\/documentation\/arinote","title":"Ari's Notes","role":"collection"}}}