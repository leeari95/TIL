{"variants":[{"paths":["\/documentation\/arinote\/211226_associated_type,_responder_chain,_touch_event,_run_loop"],"traits":[{"interfaceLanguage":"swift"}]}],"identifier":{"url":"doc:\/\/AriNote\/documentation\/AriNote\/211226_associated_type,_Responder_Chain,_Touch_Event,_Run_Loop","interfaceLanguage":"swift"},"hierarchy":{"paths":[["doc:\/\/AriNote\/documentation\/AriNote","doc:\/\/AriNote\/documentation\/AriNote\/UIKit"]]},"metadata":{"roleHeading":"Article","role":"article","modules":[{"name":"Ari's Notes"}],"title":"211226 associated type, Responder Chain, Touch Event, Run Loop"},"primaryContentSections":[{"kind":"content","content":[{"anchor":"TIL-Today-I-Learned","text":"TIL (Today I Learned)","level":1,"type":"heading"},{"inlineContent":[{"type":"text","text":"12월 26일 (일)"}],"type":"paragraph"},{"text":"학습 내용","level":2,"anchor":"%ED%95%99%EC%8A%B5-%EB%82%B4%EC%9A%A9","type":"heading"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"associated type","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"Responder Chain"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Touch Event","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Run Loop"}]}]}]},{"inlineContent":[{"text":" ","type":"text"}],"type":"paragraph"},{"type":"heading","text":"고민한 점 \/ 해결 방법","anchor":"%EA%B3%A0%EB%AF%BC%ED%95%9C-%EC%A0%90--%ED%95%B4%EA%B2%B0-%EB%B0%A9%EB%B2%95","level":2},{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"[associated type]"}]}]},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"프로토콜에서 사용되는 제네릭 Placeholder의 느낌이다."}]}]},{"content":[{"inlineContent":[{"text":"associated type은 원래 typealias였는데, Swift 2.2부터 Associated Type이란 키워드로 바뀌었다.","type":"text"}],"type":"paragraph"}]}],"type":"unorderedList"},{"syntax":"swift","code":["protocol Test {","    associatedtype MyType","    var name: MyType { get }","}"],"type":"codeListing"},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"text","text":"만약 정의된 프로퍼티가 String이나 다른 타입이 될 수 있는 여지가 있다면 위 예제처럼 associatedtype 키워드를 사용하면 된다."}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"프로토콜을 채택하여 구현할 시에는 MyType이 아니라 String, Int 등등 원하는 타입으로 정의하여 구현해줄 수 있게 된다."}]}]}],"type":"unorderedList"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"associated type은 제약을 줄 수도 있다."}]}]}]},{"type":"codeListing","syntax":"swift","code":["protocol Test {","    associatedtype MyType: Equatable","    var name: MyType { get }","}"]},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"text":"이렇게 제약사항을 걸어주면 name이 무슨 타입인진 모르겠지만 Equatable을 준수하는 타입이어야 한다고 제약사항을 걸어주게 되는 것이다.","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"따라서 Associated Type은 진짜 타입을 주는 것이 아니라 타입의 견본을 주는 것이라고 볼 수 있다."}]},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"text","text":"사용할 실제 타입은 프로토콜이 적용될 때 까지 지정되지 않으니 유용하게 쓸 수 있다."}],"type":"paragraph"}]}]}]}]},{"type":"thematicBreak"},{"inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"[Using Responders and the Responder Chain to Handle Events]"}]}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"text":"앱은 responder 객체를 이용하여 이벤트를 핸들링한다.","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"responder 객체는 UIResponder클래스의 인스턴스이고, 공통적으로 UIView, UIViewController, UIApplication 객체를 서브클래스 한다."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Responder는 이벤트 데이터를 받거나 처리하고, 아니면 다른 Responder 객체로(해당 이벤트를 해결할 수 있는)전달해야 한다.","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"앱이 이벤트를 받으면 UIKit은 가장 적절한 first responder에게 이벤트를 보낸다."}]}]},{"content":[{"inlineContent":[{"type":"text","text":"처리되지 않은(Unhandled)이벤트는 responder chain에 의해서 resopnder객체로 전달된다."}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"identifier":"https:\/\/i.imgur.com\/7FTLl6M.png","type":"image"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"만약 텍스트필드가 이벤트를 핸들링하지 않으면, UIKit은 이벤트를 상위 UIView로 보낸다."}]}]},{"content":[{"inlineContent":[{"text":"윈도우까지 이벤트가 전달됐음에도 이벤트를 핸들링할 수 없으면 이벤트는 UIApplication까지 전달되며, and possibly to the app delegate if that object is an instance of UIResponder and not already part of the responder chain….??","type":"text"}],"type":"paragraph"}]}]},{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"text":"[이벤트의 first responder 결정하기]","type":"text"}]}]},{"type":"aside","name":"Note","content":[{"inlineContent":[{"text":"UIKit은 이벤트의 타입에 따라서 FirstResponder 객체를 지정한다.","type":"text"}],"type":"paragraph"}],"style":"note"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Touch event"}]},{"type":"text","text":" 터치가 일어난 뷰"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"inlineContent":[{"text":"Press event","type":"text"}],"type":"strong"},{"type":"text","text":" 초점을 갖는 객체"}]}]},{"content":[{"inlineContent":[{"type":"strong","inlineContent":[{"text":"Shake-motin event","type":"text"}]},{"type":"text","text":" 직접 지정했거나 UIKit이 지정한 객체"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"inlineContent":[{"type":"text","text":"Remote-Control event"}],"type":"strong"},{"type":"text","text":" 직접 지정했거나 UIKit이 지정한 객체"}]}]},{"content":[{"inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Editing menu messages"}]},{"type":"text","text":" 직접 지정했거나 UIKit이 지정한 객체"}],"type":"paragraph"}]}]},{"type":"aside","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Note"},{"type":"text","text":" "},{"type":"text","text":"가속 움직임, 자이로스콥, 자력 탐지와 같은 모션 이벤트는 리스폰더를 따르지 않는 대신 코어모션이 지정된 객체에 이런 이벤트를 전달한다."}]}],"name":"Note","style":"note"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"컨트롤은 액션 메세지를 사용해 직접 관련이 있는 목표 객체와 소통한다.","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"사용자 컨트롤과 상호작용하면 컨트롤은 목표 객체에 액션메세지를 보낸다.","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"액션 메세지는 이벤트가 아니다.그러나 여전히 Responder chain을 이용한다.","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"컨트롤러 목표 객체가 "},{"code":"nil","type":"codeVoice"},{"type":"text","text":"일 때 "},{"type":"codeVoice","code":"UIKit"},{"type":"text","text":"은 목표 객체로 부터 시작해 메뉴는 "},{"type":"codeVoice","code":"cut(_:)"},{"type":"text","text":", "},{"type":"codeVoice","code":"copy(_:)"},{"text":", ","type":"text"},{"type":"codeVoice","code":"paste(_:)"},{"type":"text","text":"와 같은 이름을 가진 메소드를 구현한 Responder 객체를 탐색하기 위해 앞서 설명한 동작을 사용한다."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"GestureRecognizer는 터치와 프레스 이벤트를 뷰가 받기전에 받는다."}]}]},{"content":[{"inlineContent":[{"type":"text","text":"만약 뷰의 "},{"code":"GestureRecognizer","type":"codeVoice"},{"text":"가 터치의 연속을 인식하는 것에 실패한다면, ","type":"text"},{"type":"codeVoice","code":"UIKit"},{"type":"text","text":"은 뷰에 터치를 보낸다."}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"만약 뷰가 터치를 처리하지 않는다면 ","type":"text"},{"type":"codeVoice","code":"UIKit"},{"type":"text","text":"은 터치를 "},{"code":"Responder chain","type":"codeVoice"},{"type":"text","text":"으로 전달한다."}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"GestureRecognizer의 이벤트 처리와 관련한 내용은 ","type":"text"},{"identifier":"https:\/\/developer.apple.com\/documentation\/uikit\/touches_presses_and_gestures\/handling_uikit_gestures","isActive":true,"type":"reference"},{"type":"text","text":"를 살펴보기 바란다."}]}]}]},{"inlineContent":[{"type":"strong","inlineContent":[{"text":"[어떤 Responder가 터치 이벤트를 가져야하는지 결정하기]","type":"text"}]}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"text":"UIKit은 터치 이벤트가 어디에서 발생했는지 결정하기 위해 view-based hit testing을 사용한다.","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"구체적으로 UIKit은 뷰 계층구조에서 뷰 객체의 bounds에 터치 위치를 비교한다."}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"UIView의 ","type":"text"},{"code":"hitTest(_:with:)","type":"codeVoice"},{"type":"text","text":" 메소드는 뷰 계층구조를 따라 터치이벤트에 대한 First Responder가 될 수 있는 특정 터치를 포함한 가장 깊은 하위뷰를 탐색한다."}]}]}]},{"style":"note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Note"},{"type":"text","text":" "},{"type":"text","text":"만약 터치 위치가 뷰의 bounds 밖에 있다면, "},{"type":"codeVoice","code":"hitTest(_:with:)"},{"type":"text","text":" 메소드는 해당 뷰와 그 뷰의 모든 하위뷰를 무시한다. 결과적으로 뷰의 "},{"code":"clipsToBounds","type":"codeVoice"},{"text":" 속성이 ","type":"text"},{"type":"codeVoice","code":"false"},{"type":"text","text":"일 경우 뷰 bounds의 하위뷰 밖은 터치가 발생했다고 하더라도 반환되지 않는다. hit-testing 동작에 대한 더 많은 정보는 "},{"type":"codeVoice","code":"UIView"},{"type":"text","text":"에서 "},{"isActive":true,"type":"reference","identifier":"https:\/\/velog.io\/@panther222128\/Responder-Chain#:~:text=https%3A\/\/developer.apple.com\/documentation\/uikit\/uiview\/1622469%2Dhittest"},{"text":" 메소드를 살펴보기 바란다.","type":"text"}]}],"name":"Note","type":"aside"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"터치가 발생하면 ","type":"text"},{"type":"codeVoice","code":"UIKit"},{"text":"은 ","type":"text"},{"code":"UITouch","type":"codeVoice"},{"text":"객체를 생성하고 이를 뷰에 연관시킨다.","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"터치 위치 혹은 다른 파라미터가 변경되면 "},{"type":"codeVoice","code":"UIKit"},{"text":" 같은 ","type":"text"},{"type":"codeVoice","code":"UITouch"},{"text":" 객체에 새로운 정보를 업데이트 한다.","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"변경되지 않는 속성은 오직 View이다."}]},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"text":"터치 위치가 기존 뷰 밖으로 이동하더라도 터치의 뷰 속성에서 값은 변경되지 않는다.","type":"text"}],"type":"paragraph"}]}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"터치가 끝나면 "},{"code":"UIKit","type":"codeVoice"},{"text":"은 ","type":"text"},{"type":"codeVoice","code":"UITouch"},{"text":" 객체를 해제한다.","type":"text"}]}]}]},{"type":"paragraph","inlineContent":[{"inlineContent":[{"type":"text","text":"[Responder Chain을 바꾸기]"}],"type":"strong"}]},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"text","text":"Responder 객체의 다음 속성을 override하므로써 Responder Chain을 변경할 수 있다. 이렇게 할 경우 다음 Responder는 반환한 객체가 된다."}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"많은 "},{"type":"codeVoice","code":"UIKit"},{"type":"text","text":" 클래스가 이미 이 속성을 override하고 있으며 특정 객체를 반환한다. 아래 내용을 포함한다."}]},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"code":"UIKit","type":"codeVoice"},{"text":" 객체. 만약 View가 ViewController의 root View이면, 다음 Responder는 ViewController이다. 그렇지 않다면 다음 Responder는 뷰의 Super view이다.","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"UIViewController"},{"text":" 객체","type":"text"}]},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"만약 뷰 컨트롤러의 뷰가 윈도우의 root View이면 다음 Responder는 Window 객체다."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"만약 ViewController가 다른 뷰 컨트롤러에 의해 제시되었었다면, 다음 Responder는 해당 뷰 컨트롤러를 제시한 ViewController이다.","type":"text"}]}]}],"type":"unorderedList"}]},{"content":[{"inlineContent":[{"type":"codeVoice","code":"UIWindow"},{"text":" 객체. 윈도우의 다음 Responder는 ","type":"text"},{"code":"UIApplication","type":"codeVoice"},{"type":"text","text":" 객체다."}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"code":"UIApplication","type":"codeVoice"},{"text":" 객체. 다음 리스폰더는 AppDelegate이다. AppDelegate가 ","type":"text"},{"type":"codeVoice","code":"UIResponder"},{"text":"의 인스턴스일 때에만 그렇다. View, ViewController, App 객체 자체일 때는 그렇지 않다.","type":"text"}]}]}],"type":"unorderedList"}]}]},{"type":"thematicBreak"},{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"text":"[Touches, Presses, and Gestures]","type":"text"}]}]},{"name":"Note","type":"aside","style":"note","content":[{"inlineContent":[{"type":"text","text":"Gesture recognizers에 있는 앱의 이벤트 처리 로직을 캡슐화하므로써 앱에서 해당 코드를 재사용할 수 있게 한다."}],"type":"paragraph"}]},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"text":"표준 ","type":"text"},{"code":"UIKit","type":"codeVoice"},{"type":"text","text":" 뷰와 컨트롤을 사용해 앱을 빌드하고 있다면, "},{"type":"codeVoice","code":"UIKit"},{"type":"text","text":"은 자동으로 터치 이벤트(멀티 터치 포함)을 자동으로 처리한다."}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"그러나 컨텐츠를 보여주기 위한 커스텀 뷰를 사용하는 경우 뷰에서 발생하는 터치 이벤트 모두는 직접 처리해야한다.","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"터치이벤트를 직접 처리하는 방법은 두가지가 있다."}],"type":"paragraph"},{"items":[{"content":[{"inlineContent":[{"text":"터치를 추적하기 위해 gesture recognizers를 사용한다. Handling UIKit Gestures를 참고바란다.","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"code":"UIView","type":"codeVoice"},{"text":" 서브 클래스에서 직접 터치를 추적한다 Handling Touches in Your View를 참고바란다.","type":"text"}],"type":"paragraph"}]}],"type":"unorderedList"}]}]},{"type":"thematicBreak"},{"type":"paragraph","inlineContent":[{"inlineContent":[{"type":"text","text":"[Handling UIKit Gestures]"}],"type":"strong"}]},{"content":[{"inlineContent":[{"text":"Gestrue recognizer를 사용하는 것은 뷰에서 발생하는 Touch나 Press 이벤트를 다룰 수 있는 가장 간단한 방법이다. 어떤 뷰든간에 한개 혹은 여러개의 Gesture에 대한 Recognizer를 붙일 수 있다. Gestrue recognizer는 뷰 위에서 발생하는 일련의 패턴이 존재하는 이벤트들 (Double-Tap, Swipe, Pinch 등등)을 처리하기 위해 Target-Action 패턴을 사용하고 이벤트가 발생하면 Target객체에 이러한 사실을 전달하여 해당 이벤트를 처리할 수 있는 액션 메소드를 호출한다.","type":"text"}],"type":"paragraph"}],"name":"Note","type":"aside","style":"note"},{"inlineContent":[{"type":"image","identifier":"https:\/\/i.imgur.com\/TFTEfOX.png"}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"Gestrue Recognizer에는 두 종류가 있다.","type":"text"}]},{"items":[{"content":[{"inlineContent":[{"type":"text","text":"불연속 Gestrue Recognizer"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"이벤트를 인식한 후 액션 메소드를 한번만 호출"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"UITapGestrueRecognizer"}]}]}],"type":"unorderedList"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"연속 Gestrue Recognizer"}]},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"text","text":"최초 이벤트 인식 후 이벤트의 변화를 추적하며 액션 메소드를 변화에 맞춰 호출"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"UIPanGestureRecognizer"}]}]}]}]}],"type":"unorderedList"}]}]},{"type":"paragraph","inlineContent":[{"inlineContent":[{"type":"text","text":"[Configuring a Gesture recognizer]"}],"type":"strong"}]},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Gesture recognizer 구성 단계"}]},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"text","text":"스토리 보드에서 Gesture Recognizer를 뷰 위에 드래그하여 올려놓는다."}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"액션 메소드를 구현한다.","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"액션 메소드와 Gesture Recognizer를 연결한다.","type":"text"}]}]}]}]},{"content":[{"inlineContent":[{"text":"코드로 이를 구현할 때는 ","type":"text"},{"code":"addGestureRecognizer(_:)","type":"codeVoice"},{"type":"text","text":"를 사용한다."}],"type":"paragraph"}]}],"type":"unorderedList"},{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"text":"[Responding to Gestures]","type":"text"}]}]},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"액션 메소드를 통해 Gesture를 적절히 처리해준다.","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"위에서 언급했듯 불연속적 Gesture는 버튼과 같이 한번의 Gesture에 대해 액션 메소드는 한번만 호출된다."}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"연속적 Gesture에 대해서는 이벤트를 추적하고 이에 맞게 액션 메소드 여러번 호출된다."}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"codeVoice","code":"UIGestureRecognizer"},{"type":"text","text":"에는 "},{"type":"codeVoice","code":"state"},{"type":"text","text":"라는 프로퍼티가 있고 이를 활용하여 액션 메소드를 구성할 수 있다."}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"연속 Gesture Recognizer에선 ","type":"text"},{"type":"codeVoice","code":".began"},{"text":", ","type":"text"},{"type":"codeVoice","code":".changed"},{"text":", ","type":"text"},{"type":"codeVoice","code":".ended"},{"type":"text","text":", "},{"type":"codeVoice","code":".cancelled"},{"text":"를 사용할 수 있다.","type":"text"}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"text":"예를 들어 ","type":"text"},{"type":"codeVoice","code":".changed"},{"text":"상태에선 뷰의 속성을 임의로 변경시키고, ","type":"text"},{"type":"codeVoice","code":".ended"},{"text":"에서는 이를 확정 짓는 등의 행위를 할 수 있다.","type":"text"}],"type":"paragraph"}]}]}]}],"type":"unorderedList"},{"type":"thematicBreak"},{"type":"paragraph","inlineContent":[{"inlineContent":[{"text":"[Run Loop]","type":"text"}],"type":"strong"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"Global Thread에선 Timer가 동작하지 않는 이유는 뭘까?","type":"text"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"해당 답을 찾기 위해 Run Loop에 대해서 공부해보자."}]}]}]}]},{"content":[{"inlineContent":[{"type":"text","text":"Run Loop가 뭘까?"}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Run Loop 객체는 소켓, 파일, 키보드 마우스 등의 입력소스를 처리하는 이벤트 처리 루프다."}]}]},{"content":[{"inlineContent":[{"type":"text","text":"쓰레드가 일해야 할 때는 일하고 일이 없으면 쉬도록 하는 목적으로 고안되었다."}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"Run Loop 입장에서 Timer는 입력이 아닌 특수한 유형이지만 Timer의 이벤트 또한 처리한다."}],"type":"paragraph"}]}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"요약 하자면 Run Loop는 입력 소스를 처리하는 ","type":"text"},{"type":"codeVoice","code":"이벤트 처리 루프"},{"type":"text","text":"이고, "},{"code":"Timer","type":"codeVoice"},{"text":" 또한 같이 처리한다는 것 같다.","type":"text"}]}]}]},{"inlineContent":[{"type":"strong","inlineContent":[{"text":"[Thread와 Run Loop]","type":"text"}]}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"Run Loop는 어디에 사용될까?","type":"text"}]},{"items":[{"content":[{"inlineContent":[{"type":"text","text":"Thread의 외부 입력 소스 및 Timer를 처리할 때 사용된다."}],"type":"paragraph"}]}],"type":"unorderedList"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"중요 핵심 단어 Thread"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"Thread는 모두 각자의 Run Loop를 가질 수 있다.","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Thread를 생성할 때 Run Loop가 자동으로 생성된다."}]}]},{"content":[{"inlineContent":[{"type":"text","text":"다만 Run Loop는 자동으로 실행되지 않는다."}],"type":"paragraph"}]}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"자동으로 생성 되는 것은 맞지만 자동으로 실행되진 않는다."}]}]},{"content":[{"inlineContent":[{"text":"Run Loop 실행에 대한 관리는 프로그래머의 몫이다.","type":"text"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Main Run Loop는 예외이다."}]}]},{"content":[{"inlineContent":[{"type":"image","identifier":"https:\/\/i.imgur.com\/OFvM1l2.png"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Main Thread는 애플리케이션이 실행될 때 프레임워크 차원에서 자동으로 RunLoop를 설정하고 실행한다. 이를 Main RunLoop라고 한다."}]}]}],"type":"unorderedList"}]},{"content":[{"inlineContent":[{"type":"text","text":"따라서 Thread를 생성했는데 이 Thread가 입력소스나 Timer를 처리해야 한다면, "},{"code":"Run Loop를 직접 얻어서 실행","type":"codeVoice"},{"text":"시켜 주어야 한다.","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"내가 생성한 Thread에 대한 Run Loop를 생성해서 얻으려면 다음 메소드를 이용한다."}]}]}]},{"syntax":"swift","type":"codeListing","code":["class var current: RunLoop { get }"]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"현재 실행중인 쓰레드 내에서 다음과 같이 작성하면 현재 Thread에 대한 RunLoop를 얻을 수 있다."}]}]}]},{"code":["let runLoop = RunLoop.current"],"type":"codeListing","syntax":"swift"},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"text","text":"그러나 내가 RunLoop를 얻는 것 만으로는 입력 소스 및 타이머를 처리해주진 않는다."}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"Run이라는 것을 통해 RunLoop를 직접 실행 시켜주어야 하는데, 이것에 대해 알기 위해 Run Loop가 어떻게 작동하는지 알아보자","type":"text"}],"type":"paragraph"}]}]},{"type":"paragraph","inlineContent":[{"inlineContent":[{"text":"[RunLoop의 작동 원리]","type":"text"}],"type":"strong"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"RunLoop는 루프 수행할 때 총 2가지 Event Source를 수신한다."}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"Input Source","type":"text"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"다른 Thread나 Application으로부터 온 비동기 이벤트를 전달한다."}]}]}]}]},{"content":[{"inlineContent":[{"type":"text","text":"Timer"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"예약된 시간 또는 반복 간격으로 발생하는 동기 이벤트를 전달한다.","type":"text"}]}]}],"type":"unorderedList"}]}]}]}]},{"inlineContent":[{"identifier":"https:\/\/i.imgur.com\/vfgJdur.png","type":"image"}],"type":"paragraph"},{"type":"aside","name":"Note","style":"note","content":[{"inlineContent":[{"type":"strong","inlineContent":[{"text":"Input Source","type":"text"}]},{"text":" 핸들러에 비동기 이벤트를 전달하고 runUntilDate 메소드가 종료","type":"text"},{"text":" ","type":"text"},{"type":"strong","inlineContent":[{"type":"text","text":"Timer Source"}]},{"text":" 핸들러에 이벤트를 전달하지만 런 루프를 종료하진 않음","type":"text"},{"text":" ","type":"text"},{"text":"런 루프는 동작에 대해 노티피케이션을 생성","type":"text"},{"text":" ","type":"text"},{"text":"등록된 런 루프 옵저버를 통해 알림을 수신하고 추가 처리를 위해 스레드에 구현하는 것이 가능","type":"text"}],"type":"paragraph"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"왼쪽 그림에서 노란색 루프를 한바퀴 도는 작업이 한번의 실행이라고 생각했을 때,","type":"text"}]},{"items":[{"content":[{"inlineContent":[{"text":"RunLoop는 한번의 실행 동안 내 Thread에 도착한 이벤트를 받고, 이에 대한 핸들러를 수행하는 객체","type":"text"}],"type":"paragraph"}]}],"type":"unorderedList"}]},{"content":[{"inlineContent":[{"type":"text","text":"루프라고 해서 RubnLoop가 자체적으로 계속 이벤트가 들어오나 안들어오나 실행을 반복 한다고 생각할 수 있겠지만, RunLoop는 내부적으로 반복 실행을 하지 않는다."}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"한번 Event Source를 읽고 전달하는 실행이 끝나면, 그대로 대기한다.","type":"text"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"그 다음 Event Source가 들어와도 RunLoop는 대기 상태이기 때문에 Event를 받을 수 없는 것이다."}]}]}],"type":"unorderedList"}]},{"content":[{"inlineContent":[{"text":"따라서 Thread 내에서 프로그래머가 명시적으로 for, while 등을 이용해 RunLoop를 반복 실행 시켜주어야 한다.","type":"text"}],"type":"paragraph"}]}]},{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"[RunLoop를 실행시키는 방법]"}]}]},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"text","text":"아까 Global Thread에서 왜 Timer가 실행되지 않은지에 대해 원인을 정리해보자면,"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"Global Thread를 손수 생성했고","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"내가 생성한 Global Thread의 RunLoop는 실행되고 있지 않기 때문에,"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Timer를 작동 시켰지만, 내 Thread의 RunLoop가 이 Event를 처리하지 못해서 실행이 안됐던 것이였다."}]}]}],"type":"unorderedList"}]},{"content":[{"inlineContent":[{"text":"따라서 Global Thread에서 RunLoop를 실행 시키는 방법은 아래 메소드를 활용하는 것이다.","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"identifier":"https:\/\/i.imgur.com\/jOKErSA.png","type":"image"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Loop를 Running 시키는 방법 중 4가지 메소드를 알아보자","type":"text"}]},{"items":[{"content":[{"inlineContent":[{"type":"codeVoice","code":"run()"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"receiver를 영구 루프에 넣고, 이 기간 동안 모든 부착된 Input Sourcer의 데이터를 처리한다.","type":"text"}]}]}],"type":"unorderedList"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"run(mode:before:)"}]},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"루프를 한 번 실행하여 지정된 모드에서 지정된 날짜까지 input을 blocking한다.","type":"text"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"RunLoop Mode에 대해서 참고해보자."}]}]}]}]}],"type":"unorderedList"}]},{"content":[{"inlineContent":[{"code":"run(until:)","type":"codeVoice"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"지정된 날짜까지 루프를 실행하고, 그 기간 동안 루프는 부착된 모든 Inptu Source들의 데이터를 처리한다.","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"보통 RunLoop를 반복 실행할 때 이 메소드를 사용한다."}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"만약 더이상 RunLoop가 필요없어지면 아래 코드 예제의 while문을 false로 해주어 RunLoop가 더이상 작동하지 않도록 설정하면 된다."}]}]}],"type":"unorderedList"},{"syntax":"swift","type":"codeListing","code":["while isRunning {","    runLoop.run(until: Date().addingTimeInterval(0.1))","}"]}]},{"content":[{"inlineContent":[{"code":"acceptInput(forMode:before:)","type":"codeVoice"}],"type":"paragraph"},{"items":[{"content":[{"inlineContent":[{"type":"text","text":"지정된 날짜까지 또는 지정된 모드에 대해서만 입력을 허용하여 루프를 한번만 실행한다."}],"type":"paragraph"}]}],"type":"unorderedList"}]}],"type":"unorderedList"}]}]},{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"text":"[언제 RunLoop를 사용할까?]","type":"text"}]}]},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"Input Source를 통해 다른 Thread와 통신하는 경우","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"Timer를 사용해야 하는 경우"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Perform Selector Source를 사용해야 하는 경우"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"주기적인 일을 계속 수행해야 하는 경우","type":"text"}]}]},{"content":[]}],"type":"unorderedList"},{"type":"thematicBreak"},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"text","text":"참고링크"}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"https:\/\/taekki-dev.tistory.com\/34"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"https:\/\/zeddios.tistory.com\/382"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"https:\/\/seizze.github.io\/2019\/11\/26\/iOS%EC%9D%98-Responder%EC%99%80-Responder-Chain-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0.html"}]}]},{"content":[{"inlineContent":[{"text":"https:\/\/developer.apple.com\/documentation\/uikit\/touches_presses_and_gestures\/using_responders_and_the_responder_chain_to_handle_events","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"https:\/\/velog.io\/@panther222128\/Touches-Presses-and-Gestures#:~:text=0-,https%3A\/\/developer.apple.com\/documentation\/uikit\/touches_presses_and_gestures,-%22Encapsulate%20your%20app%27s","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"https:\/\/baked-corn.tistory.com\/130","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"https:\/\/developer.apple.com\/documentation\/uikit\/touches_presses_and_gestures\/implementing_a_custom_gesture_recognizer\/implementing_a_continuous_gesture_recognizer?changes=_4","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"https:\/\/developer.apple.com\/library\/archive\/documentation\/Cocoa\/Conceptual\/Multithreading\/RunLoopManagement\/RunLoopManagement.html"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"https:\/\/babbab2.tistory.com\/68"}],"type":"paragraph"}]}]}]}]}]}],"schemaVersion":{"patch":0,"major":0,"minor":3},"kind":"article","sections":[],"references":{"https://i.imgur.com/OFvM1l2.png":{"identifier":"https:\/\/i.imgur.com\/OFvM1l2.png","alt":null,"variants":[{"traits":["1x","light"],"url":"https:\/\/i.imgur.com\/OFvM1l2.png"}],"type":"image"},"https://i.imgur.com/TFTEfOX.png":{"identifier":"https:\/\/i.imgur.com\/TFTEfOX.png","alt":null,"variants":[{"traits":["1x","light"],"url":"https:\/\/i.imgur.com\/TFTEfOX.png"}],"type":"image"},"https://i.imgur.com/vfgJdur.png":{"identifier":"https:\/\/i.imgur.com\/vfgJdur.png","alt":null,"variants":[{"traits":["1x","light"],"url":"https:\/\/i.imgur.com\/vfgJdur.png"}],"type":"image"},"https://i.imgur.com/7FTLl6M.png":{"identifier":"https:\/\/i.imgur.com\/7FTLl6M.png","alt":null,"variants":[{"traits":["1x","light"],"url":"https:\/\/i.imgur.com\/7FTLl6M.png"}],"type":"image"},"doc://AriNote/documentation/AriNote/UIKit":{"kind":"article","title":"UIKit","abstract":[{"type":"text","text":"한몸이 되보자…"}],"type":"topic","role":"collectionGroup","identifier":"doc:\/\/AriNote\/documentation\/AriNote\/UIKit","url":"\/documentation\/arinote\/uikit"},"https://i.imgur.com/jOKErSA.png":{"identifier":"https:\/\/i.imgur.com\/jOKErSA.png","alt":null,"variants":[{"traits":["1x","light"],"url":"https:\/\/i.imgur.com\/jOKErSA.png"}],"type":"image"},"https://developer.apple.com/documentation/uikit/touches_presses_and_gestures/handling_uikit_gestures":{"identifier":"https:\/\/developer.apple.com\/documentation\/uikit\/touches_presses_and_gestures\/handling_uikit_gestures","titleInlineContent":[{"type":"text","text":"Handling UIKit Gestures"}],"url":"https:\/\/developer.apple.com\/documentation\/uikit\/touches_presses_and_gestures\/handling_uikit_gestures","type":"link","title":"Handling UIKit Gestures"},"https://velog.io/@panther222128/Responder-Chain#:~:text=https%3A//developer.apple.com/documentation/uikit/uiview/1622469%2Dhittest":{"identifier":"https:\/\/velog.io\/@panther222128\/Responder-Chain#:~:text=https%3A\/\/developer.apple.com\/documentation\/uikit\/uiview\/1622469%2Dhittest","titleInlineContent":[{"type":"codeVoice","code":"hitTest(_:with:)"}],"url":"https:\/\/velog.io\/@panther222128\/Responder-Chain#:~:text=https%3A\/\/developer.apple.com\/documentation\/uikit\/uiview\/1622469%2Dhittest","type":"link","title":"hitTest(_:with:)"},"doc://AriNote/documentation/AriNote":{"kind":"symbol","type":"topic","identifier":"doc:\/\/AriNote\/documentation\/AriNote","abstract":[{"type":"codeVoice","code":"Today I Learned"}],"url":"\/documentation\/arinote","title":"Ari's Notes","role":"collection"}}}