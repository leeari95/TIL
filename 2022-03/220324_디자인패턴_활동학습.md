# 220324 디자인패턴 활동학습

# TIL (Today I Learned)

3월 24일 (목)

## 학습 내용

- 디자인패턴 활동학습
    - Chain of Responsibility
    - Command
    - Interpreter
    - Visitor
    - Proxy
    - Template
    - Bulider
    - Factory
    - Abstract Factory

&nbsp;

## 고민한 점 / 해결 방법

**[Chain of Responsibility Pattern]**

요청을 처리하는 모듈을 만들어서 체인 형태로 구성하는 디자인 패턴.
하나의 모듈이 어떤 작업을 처리한 다음 다른 모듈로 결과를 전달하고, 다른 모듈도 해야 할 작업을 처리한 다음 또 다른 모듈로 전달한다.

### 구조

* Handler
    * 클라이언트의 요청을 처리하기 위한 인터페이스를 정의
    * 현재 핸들러에서 처리하지 않을 것이라면 요청을 넘길 다음 핸들러를 구현한다.
        * 처리할 수 없는 요청인 경우 마지막 핸들러까지 가서도 처리되지 않을 수 있다. 마지막 핸들러는 다음 핸들러를 갖지 않을 것이므로 이는 선택적으로 만들면 된다.
* Concrete Handler
    * 요청을 처리한다.
    * 다음 핸들러에 작업을 넘긴다.
* Client
    * Chain의 첫번째 Concrete Handler 객체에 요청을 한다.
        * 이를 요청하기 위해 클라이언트가 첫번째 Concrete Handler에 접근할 수 있어야 한다.
    * 클라이언트의 요청은 Chain에 존재하는 모든 핸들러로 전송될 수 있다.

### 언제 사용할까?

* 유사한 이벤트를 처리하지만 이벤트의 타입, 속성, 기타 항목에 따라 달라지는 객체 그룹이 있을 때 책임 연쇄 패턴을 사용하면 좋다.


### 장점

* 요청 서리 순서를 제어할 수 있다
* 결합도를 감소시켜준다.
    * 체인에 존재하는 객체들은 요청을 처리할 것인지 넘길 것인지만 판단하면 되고, 체인의 다른 객체들이 뭘하는지 알 필요가 없다.
* Single Responsibility Principle(단일 책임 원칙)을 지킬 수 있다. 작업을 수행하는 클래스, 작업을 호출하는 클래스를 분리할 수 있다.
* Open, Closed Principle(개방/폐쇄 원칙)을 지킬 수 있다. 기존 클라이언트의 코드를 바꾸지 안혹 새로운 핸들러를 앱에 추가할 수 있다.

### 단점

* 처리되지 않는 요청이 있을 수 있지만, 요청할 때는 이걸 알 수가 없다. 체인이 끝까지 가야 알 수 있기 때문이다.
* 체인을 잘못만들 경우 사이클이 발생할 수 있다.


---

**[Command Pattern]**

요청이나 간단한 작업을 객체로 캡슐화하여 이를 큐나 log로 처리하는 방법이다.
이렇게 캡슐화한 작업은 실행 취소를 할 수도 있게 만들 수 있다.

### 구조

* Command
    * 작업을 실행하기 위한 인터페이스를 정의한다
    * Command를 실행하기 위한 하나의 메서드로 이루어진 경우가 많다.
* Concrete Command
    * Receiver 객체와 작업 사이 바인딩을 정의한다.
    * Receiver에서 해당 작업을 호출하여 실행한다.
    * 직접 작업을 수행하는 것이 아닌 Receiver에게 전달하기 위한 목적을 갖고 있다.
    * 코드를 단순화 하기 위해 클래스를 합칠 수도 있다.
* Client
    * Concrete Command 객체를 만들고 Receiver를 설정한다.
    * Receiver의 인스턴스를 포함한 작업에 필요한 모든 매개변수를 Command의 생성자에 전달하여 작업을 처리한다.
* Invoker
    * Invoker 클래스에는 명령 객체에 대한 참조를 저장하기 위한 필드가 있어야 한다.
    * 클라이언트가 생성자를 통해 Invoker 객체를 만들 때 Command 객체를 받게 된다.
    * 요청을 Receiver에게 직접 보내는 것이 아닌 해당 요청의 시작을 담당으로 한다.
* Receiver
    * 웬만한 클래스는 Receiver 역할을 할 수 있다.
    * 요청된 작업을 수행한다.


### 언제 사용할까?

작업르 캡슐화해서 Receiver에게 보내서 처리하고 싶을 때 사용하면 좋다.

### 장점

* 단일 책임 원칙을 준수한다. Command 객체를 통해 작업을 수행하는 객체와 작업을 호출하는 객체를 나눌 수 있다.
* 개방 폐쇄 원칙을 준수한다. 클라이언트의 코드를 수정하지 않고도 새로운 Command를 추가할 수 있다.
* 실행 취소, 다시 실행을 구현할 수 있다.
* 작업의 시작을 지연시킬 수 있다.
* 여러 개의 단순한 명령을 조합해서 복잡한 명령을 만들 수 있다.

### 단점

* Receiver, Invoker 사이에 관계를 도입해야 하므로 코드가 복잡해질 수 있다.

---

**[Interpreter Pattern]**

언어가 주어지면 해당 표현을 사용하여 언어로 문장을 해석하는 인터프리터를 사용하여 문법 표현을 정의하는 방법이다.

### 구조

* Abstract Expression
    * Abstract Syntax Tree의 모든 노드에서 사용할 Interpret 작업을 정의한다.
* Terminal Expression
    * 터미널 기호와 관련된 작업을 구현한다.
    * 문장의 모든 터미널 기호에 인스턴스가 필요하다.
    * 여기서 말하는 터미널 기호라고 함은 어떤 문장에서 의미있는 최소의 단위를 뜻한다.
* Nonterminal Expression
    * 하나의 클래스는 문법이 가진 모든 규칙을 필요로 한다.
    * R1... Rn Symbol 각각에 대한 AbstractExpression 타입의 인스턴스 변수를 유지한다.
    * Grammar에서 Nonterminal Symbol에 대한 해석 연산을 구현한다. Interpret는 R1... Rn까지의 규칙을 나타내는 변수를 통해 재귀적 방식으로 해석한다.
* Context
    * Interpreter가 해석할 문장
    * 해석의 대상이 되는 문자열을 Expression 할 수 있도록 전달한다.
* Client
    * 실제로 Interpreter를 호출하는 부분

### 언제 사용할까?

* 어떤 언어의 문법을 정의하고 해석할 때 주로 활용한다.
* 정규표현식, 번역기 등이 좋은 예시가 될 듯

### 장점

* 새로운 패턴에 대응하는 Expression을 쉽게 추가할 수 있다.
* 해석 대상이 규칙만 가지고 있다면 적용이 가능하므로 활용범위가 무궁무진하다.

### 단점

* 하나의 패턴이나 규칙에 1개 이상의 Expression 클래스가 생성되므로 복잡한 문법을 갖고 있는 언어에 대해서는 관리가 쉽지 않다.

---

**[Visitor Pattern]**

알고리즘을 작동하는 객체에서 분리할 수 있는 디자인 패턴이다.

### 구조

![](https://i.imgur.com/fHrVIWZ.png)

* Visitor
    * Concrete Element를 매개변수로 사용할 수 있는 Visit 메서드들을 정의한다.
    * 언어가 오버로딩을 지원하는 경우 메서드 이름이 같을 순 있지만 매개변수 타입은 달라야 한다.
* Concrete Visitor
    * 서로 다른 Concrete Element에 맞게 메서드를 구현한다.
* Element
    * Visitor를 Accept하는 메서드를 정의한다. Accept 메서드는 Visitor 객체를 매개변수로 사용해야한다.
* Concrete Element
    * Accept 메서드를 구현한다.
    * Accept 메서드는 Element 객체에서 사용할 적절한 Visitor의 메서드를 호출하는 역할을 한다.
* Client
    * 컬레션이나 트리와 같은 자료구조를 나타낸다

### 언제 사용할까?

* 자료구조(Element)와 자료구조를 처리하는 로직(Visitor)를 분리하여, 로직이 자주 변경될 경우에 사용한다.
* 객체들이 복잡한 구조의 모든 Element에 대해 작업을 수행해야하는 경우.
* 클래스 계층 구조에서 몇몇 단계에 있는 클래스에만 의미있는 메서드가 존재할 때.

### 장점

* 작업 대상(방문 공간) 과 작업 항목(방문 공간을 가지고 하는 일)을 분리시킨다.
    * 작업 대상(방문 공간) 은 단지 데이터를 담고있는 자료구조로 만들고, 작업 주체(방문자) 는 visit() 안에 이 작업 대상을 입력받아 작업 항목을 처리하면 된다.
    * 즉, 데이터와 알고리즘이 분리되어, 데이터의 독립성을 높여준다.
* 작업 대상의 입장에서는 accept() 로 인터페이스를 통일시켜, 사용자에게 동일한 인터페이스를 제공한다.

### 단점

* 새로운 작업 대상(방문 공간)이 추가될 때마다 작업 주체(방문자)도 이에 대한 로직을 추가해야 한다.
* 두 객체 (방문자와 방문 공간)의 결합도가 높아진다.
    * 서로 visit() 과 accept() 에 의존하므로.

---

**[Proxy Pattern]**

다른 객체에 대한 접근을 제어할 수 있도록 surrogate, placeholder를 제공할 수 있는 구조 패턴
비즈니스 로직을 수행하는 실제 객체가 들어갈 자리에 대리자(Proxy)를 대신 투입하여 흐름제어 수행

### 구조

![](https://i.imgur.com/40W9dJ6.png)

* Subject
    * 서비스의 인터페이스를 정의한다.
    * 프록시는 서비스 객체로 사용할 수 있도록 인터페이스를 준수해야 한다.
* RealSubject
    * 서비스는 비즈니스 로직을 제공하는 클래스다.
* Proxy
    * 프록시 객체에는 서비스 객체를 참조하는 필드가 있다.
    * Lazy initialization, logging, access control, caching 등과 같은 작업을 완료한 뒤 클라이언트의 요청을 서비스 객체에 전달한다.
    * 참조하는 서비스 객체와 동일한 인터페이스를 준수한다.
    * 프록시에는 Remote Proxy, Virtual Proxy, Protection Proxy가 있으며 각각의 책임으로 구분한다.
    * Remote Proxy
        * 요청을 처리하고 서비스 객체에 이를 전달하는 역할을 한다.
    * Virtual Proxy
        * 서비스 객체에 대한 정보를 캐싱하여 접근을 연기한다.
    * Protection Proxy 
        * 특정 작업을 요청한 객체가 해당 작업을 수행할 권한을 가지고 있는지 확인
* Client
    * 서비스 객체가 필요한 모든 코드를 프록시에 전달하기 위해 동일한 인터페이스를 사용하는 서비스와 프록시 객체와 함께 작동해야한다.


### 언제 사용할까?

* 원본 객체가 실제로 사용될 때까지 생성 및 초기화를 위한 처리를 미루기 위해 원본 객체 대신 프록시를 노출하여 원본 객체에 대한 접근을 제어
* 큰 이미지나 그래픽 같은 큰 데이터가 로딩되는데 시간이 걸리기 때문에 처음부터 데이터를 로딩하지 않고 필요한 순간에 로딩하기 위해 사용
* 원본 객체의 코드를 바꾸지 않고 추가적인 기능을 넣고 싶을 때
* 바로 생성하는 것이 아닌 생성을 지연시키고 싶을 때

### 장점

* 클라이언트가 알지 못하는 상태에서 서비스 객체를 제어할 수 있다.
* 서비스 객체의 생명 주기를 관리할 수 있다.
* 프록시는 서비스 객체가 준비되지 않았거나 사용할 수 없는 경우에도 작동한다.
* 서비스나 클라이언트를 변경하지 않고 새로운 프록시를 도입할 수 있다.

### 단점

* 새로운 클래스를 도입해야 하므로 코드가 복잡해진다.
* 응답이 지연될 수 있다.


---

**[Template Method Pattern]**

알고리즘 단계를 메서드로 정의하고 하위클래스에서 알고리즘 단계를 재정의하는 패턴

### 구조

![](https://i.imgur.com/WwLGCRY.png)

* Abstract Class(Application)
    * 알고리즘을 단계적으로 작동하는 메서드들과 이들을 실제로 호출하는 Template Method를 정의한다.
* Concrete Class(My Application)
    * Abstract Class에서 정의한 단계적으로 작동하는 메서드들은 override할 수 있지만 Template Method는 override할 수 없다.


### 언제 사용할까?

* 클라이언트가 특정 단계를 변경, 제어하면서도 알고리즘의 실행 순서를 보장하고자 할 때

### 장점

* 중복된 코드를 Extension으로 정의하기 때문에 중복 코드를 줄일 수 있다.
* 하위 객체를 쉽게 추가, 확장할 수 있다. 알고리즘의 다른 단계에 비교적 적은 영향을 미치기 때문.


### 단점

* 이미 정의된 알고리즘만 사용할 수 있기 때문에, 일부 클라이언트의 구현이 제한되는 경우가 생길 수 있다.
* Extension의 정의부를 변경할 때, 하위 클래스 또한 수정이 필요해질 수 있다.

---

**[Factory Pattern]**

객체를 생성하는 디자인 패턴인 Crational Pattern의 일종이다.
인스턴스의 생성을 책임지는 Factory 타입을 정의하여 Factory 타입의 메서드를 통하여 인스턴스를 생성하는 것을 말한다.

### 구조

![](https://i.imgur.com/sClOU1c.png)

* 객체를 생성하는 Factory
* 이로부터 생성된 객체 Product

### 언제 사용할까?

* 비슷하지만 세부사항만 다른 여러 인스턴스들을 생성할 필요가 있을 때
* 인스턴스의 생성 로직이 너무 복잡하여 분리가 필요할 때
* 인스턴스를 생성하기 위해서 서로 다른 여러 타입을 의존해야할 때

### 장점

* 생성할 타입에 대한 불필요한, 복잡한 정보를 숨기고 꼭 필요한 조건들만 가지고 인스턴스 생성을 가능하게 해준다.
* 복잡한 객체 생성 로직들을 하나의 Factory 타입에 모아 관리할 수 있다.

---

**[Abstract Factory Pattern]**

구체적인 클래스에 의존하지 않고 관련 객체들을 모으기 위한 인터페이스를 제공하는 것
공통된 요소들을 갖는 개별 팩토리 그룹을 캡슐화 하는 방법을 제공한다.
관련있는 여러 객체를 일관된 방식으로 생성하는 경우 유용하다.

### 구조

![](https://i.imgur.com/ase7E1i.png)

* Abstract Factory
    * 인터페이스는 각각의 추상 제품을 생성하기 위한 메소드들을 선언한다.
* Concrete Factory
    *  Abstract Factory의 생성 방법을 구현한다. 각 Concrete Factory는 product의 특정 변형에 해당하며 해당 product 변형만 생성한다.
* Client
    * abstract interfaces를 통해 개체와 통신하는 한 모든 concrete factory/product 변형으로 작업할 수 있습니다.


### 언제 사용할까?

* 앱이 객체의 생성, 구성, 표현방법과 독립적이어야 할 때
* 앱이 여러 객체 중 하나로 구성되어야 할 때
* 관련 객체들이 함께 사용할 수 있게 설계할 때
* 앱의 클래스 라이브러리를 제공하고 구현이 아닌 인터페이스만 표시할 때

### 특징

* 코드를 변경하지 않고 런타임 시점에 환경(조건)에 따른 적절한 객체를 사용할 수 있다.
* 각 객체 간의 결합도를 낮출 수 있다.
* 다만 너무 깊은 단계로 구현하는 경우 복잡해지거나 코드의 흐름을 찾기가 어렵다.

---

**[Builder Pattern]**

이니셜라이저에 여러개의 파라미터를 넣는 대신, 차례차례 값을 넣어서 객체를 생성하는 것을 도와주는 패턴이다.
setter 메서드와 체이닝을 통해서 특정 객체를 조합해가는 패턴이다.

### 구조

![](https://i.imgur.com/68mu4Em.png)

* Product
    * Builder를 이용해서 Director가 만들어낸 최종 객체 / 아래 예시에서는 UILabel
* Builder
    * 객체를 생성하는 추상 인터페이스
* ConCreateBuilder
    * Builder의 구현클래스 / 예시에서는 UILabelBuilder
* Director
    * 객체를 생성하는 책임을 가짐 / Director를 통해서 생성이 이루어져야 한다

### 언제 사용할까?

* 복잡한 객체를 생성할 때
* 여러 속성을 가진 복잡한 객체를 간결하게 생성하고 싶을 때

### 장점

* 객체가 만들어지는 과정을 세밀하게 제어할 수 있다.
    * 한번에 모든 프로퍼티를 만드는 방법과 다르게, 빌더 패턴은 단계별로 객체를 만들기 때문에 이를 세밀하게 제어할 수 있다는 의미
* 코드의 길이는 짧아지고 의미는 더 명확해진다.

---

- 참고링크
    - https://wiry-launch-6ab.notion.site/Builder-Pattern-9fdefa53daff4a81b53ab9e0db9fc250
    - https://refactoring.guru/design-patterns/abstract-factory
    - https://refactoring.guru/design-patterns/template-method
    - https://icksw.tistory.com/235
    - https://icksw.tistory.com/236
